2022-04-18 23:27:04 info - node server started at port 1229
2022-04-18 23:27:05 info - node server started at port 1229
2022-04-18 23:28:40 info - node server started at port 1229
2022-04-18 23:29:03 info - node server started at port 1229
2022-04-18 23:29:25 info - node server started at port 1229
2022-04-18 23:29:37 info - node server started at port 1229
2022-04-18 23:30:20 info - node server started at port 1229
2022-04-18 23:30:37 info - node server started at port 1229
2022-04-18 23:30:39 info - code:<h1 id="ecmascript1">ECMAScript1</h1>
<blockquote><p>基本JavaScript</p>
</blockquote><h2 id="原始数据类型">原始数据类型</h2>
<p><code class='literal'>undefined</code>、<code class='literal'>null</code>、<code class='literal'>Boolean</code>、<code class='literal'>String</code>、<code class='literal'>Number</code>、<code class='literal'>Symbol</code></p>
<h2 id="引用数据类型">引用数据类型</h2>
<p><code class='literal'>Function</code>、<code class='literal'>Object</code></p>
<h2 id="字符串方法汇总">字符串方法汇总</h2>
<h3 id="padstartnumber-fill">padStart(number, fill)</h3>
<p>补全字符串,第一个参数为补全后的字符串长度,第二个参数为用来补的字符</p>
<h4 id="示例">示例</h4>
<pre><code class="language-js"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2020/04/02&quot;</span>);
<span class="hljs-keyword">var</span> year = date.<span class="hljs-title function_">getFullYear</span>();
<span class="hljs-keyword">var</span> month = date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> day = date.<span class="hljs-title function_">getDate</span>();

<span class="hljs-keyword">var</span> dateStr = <span class="hljs-string">`<span class="hljs-subst">${year}</span>-<span class="hljs-subst">${month}</span>-<span class="hljs-subst">${day}</span>`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dateStr);<span class="hljs-comment">//2020-4-2</span>

month = month.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);
day = day.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);

<span class="hljs-keyword">var</span> dateStr2 = <span class="hljs-string">`<span class="hljs-subst">${year}</span>-<span class="hljs-subst">${month}</span>-<span class="hljs-subst">${day}</span>`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dateStr2);<span class="hljs-comment">//2020-04-02</span>
</code></pre>
<h3 id="padendnumber-fill">padEnd(number, fill)</h3>
<p>功能大致同padStart,区别是在原字符串的末尾补全</p>
<blockquote><p>高级JavaScript</p>
</blockquote><h2 id="预编译">预编译</h2>
<h3 id="全局的代码预编译">全局的代码预编译</h3>
<ol>
<li>创建GO(global object)对象</li>
<li>找变量声明，将变量名作为GO对象的属性名，值为undefined</li>
<li>找函数声明，将函数名作为GO对象的属性名，值为函数体</li>
</ol>
<h3 id="函数体中代码预编译函数执行时">函数体中代码预编译(函数执行时)</h3>
<ol>
<li>创建AO(activation object)对象</li>
<li>找变量声明和形参，将变量名和形参名作为AO对象的属性名，值为undefined</li>
<li>实参值和形参统一，即将实参值赋给形参</li>
<li>找函数声明，将函数名作为AO对象的属性名，值为函数体</li>
</ol>
<h2 id="三种区分一个变量是object类型还是array类型的方法">三种区分一个变量是Object类型还是Array类型的方法</h2>
<h3 id="1使用instanceof">1.使用instanceof</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {},
    arr = [];
<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj is Object&quot;</span>);
}
<span class="hljs-keyword">if</span> (arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr is Array&quot;</span>);
}
</code></pre>
<p><img src="img/%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AFObject%E8%BF%98%E6%98%AFArray%E4%B9%8Binstanceof.png" alt="运行结果"></p>
<blockquote><p>当变量arr是数组时，使用：arr instanceof Object 语句得到的结果仍然是true</p>
</blockquote><h3 id="2使用constructor">2.使用constructor</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {},
    arr = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">constructor</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">constructor</span>);
</code></pre>
<p><img src="img/%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AFObject%E8%BF%98%E6%98%AFArray%E4%B9%8Bconstructor.png" alt="运行结果"></p>
<h3 id="3使用call调用object的tostring">3.使用call调用Object的toString()</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {},
    arr = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(arr));
</code></pre>
<p><img src="img/%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AFObject%E8%BF%98%E6%98%AFArray%E4%B9%8BtoString.png" alt="运行结果"></p>
<h2 id="闭包的四种用法">闭包的四种用法</h2>
<h3 id="1实现公有变量">1.实现公有变量</h3>
<pre><code class="language-js"><span class="hljs-comment">//累加器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getCounter</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        count ++;
        <span class="hljs-keyword">return</span> count;
    }
}
<span class="hljs-keyword">var</span> counter = <span class="hljs-title function_">getCounter</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>());
</code></pre>
<h3 id="2可以做缓存">2.可以做缓存</h3>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cache</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">incre</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> ++i;
        },
        <span class="hljs-attr">decre</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> --i;
        }
    }
}
<span class="hljs-keyword">var</span> cache = <span class="hljs-title function_">cache</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">incre</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">decre</span>());
</code></pre>
<h3 id="3可以实现封装，属性私有化">3.可以实现封装，属性私有化</h3>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;de&#x27;</span>, <span class="hljs-number">19</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>, p.<span class="hljs-property">age</span>);
</code></pre>
<h3 id="4模块化开发，防止污染全局变量">4.模块化开发，防止污染全局变量</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> initC = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {

    <span class="hljs-keyword">var</span> name, age;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">initContent</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">//...</span>
    }
    <span class="hljs-comment">//...</span>

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">initContent</span>();
    }

    }())

<span class="hljs-keyword">var</span> initD = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {

    <span class="hljs-keyword">var</span> name, age;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">initContent</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">//...</span>
    }
    <span class="hljs-comment">//...</span>

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">initContent</span>();
    }

    }())

<span class="hljs-comment">//程序入口</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">initC</span>();
    <span class="hljs-title function_">initD</span>();
    <span class="hljs-comment">//...</span>
}
</code></pre>
<h2 id="数组去重">数组去重</h2>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];
<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">unique</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> obj = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) {
        obj[<span class="hljs-variable language_">this</span>[i]] = <span class="hljs-variable language_">this</span>[i];
    }
    <span class="hljs-keyword">var</span> narr = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) {
        narr.<span class="hljs-title function_">push</span>(key);
    }
    <span class="hljs-keyword">return</span> narr;
}
</code></pre>
<h2 id="深度拷贝">深度拷贝</h2>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">tar, ori</span>) {
    <span class="hljs-keyword">var</span> origin = ori || {};
    <span class="hljs-keyword">var</span> toStr = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> tar) {
        <span class="hljs-keyword">if</span> (toStr.<span class="hljs-title function_">call</span>(tar[key]) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>) {
            origin[key] = [];
            <span class="hljs-title function_">clone</span>(tar[key], origin[key]);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (toStr.<span class="hljs-title function_">call</span>(tar[key]) === <span class="hljs-string">&#x27;[object Object]&#x27;</span>) {
            origin[key] = {};
            <span class="hljs-title function_">clone</span>(tar[key], origin[key]);
        } <span class="hljs-keyword">else</span> {
            origin[key] = tar[key];
        }
    }
    <span class="hljs-keyword">return</span> origin;
}

<span class="hljs-comment">//举例</span>
<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hh&#x27;</span>,
    <span class="hljs-attr">skill</span>: [
        { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;say&#x27;</span> },
        {
            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;11&#x27;</span>
        }
    ]
}
<span class="hljs-keyword">var</span> nobj = <span class="hljs-title function_">clone</span>(obj);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nobj.<span class="hljs-property">skill</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span> === obj.<span class="hljs-property">skill</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>);
</code></pre>
<h3 id="对象的深度拷贝">对象的深度拷贝</h3>
<p>使用<code class='literal'>JSON.stringify</code>将对象序列化，然后再使用<code class='literal'>JSON.parse</code>反序列化</p>
<h2 id="原型链">原型链</h2>
<h3 id="构造函数">构造函数</h3>
<ul>
<li><p>构造函数是一个首字母大写的特殊的<code class='literal'>function</code></p>
</li>
<li><p>每一个构造函数都有一个<code class='literal'>prototype</code>属性，指向另一个对象</p>
</li>
<li><p>原型是一个对象，也称<code class='literal'>prototype</code>为原型对象，它可以实现方法的共享，节省内存空间</p>
</li>
<li><p>每一个实例都有一个<code class='literal'>__proto__</code>属性，该属性指向构造函数的原型对象</p>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">//构造函数首字母大写</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Star</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sing</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我会唱歌&quot;</span>);
    }
}

<span class="hljs-keyword">let</span> ldh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&quot;刘德华&quot;</span>);
<span class="hljs-keyword">let</span> zxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&quot;张学友&quot;</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh.<span class="hljs-property">sing</span> === zxy.<span class="hljs-property">sing</span>);<span class="hljs-comment">//false,此时两个实例对象ldh和zxy的sing方法分别指向两个不同的引用</span>

<span class="hljs-title class_">Star</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">dance</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我会跳舞&quot;</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh.<span class="hljs-property">dance</span> === zxy.<span class="hljs-property">dance</span>);<span class="hljs-comment">//true,此时两个实例对象ldh和zxy的dance方法指向同一个引用，因此可以通过将一些共有方法绑定到构造函数的原型上来实现共享，节省内存空间</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Star</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">//true，每个对象都有一个__proto__属性，该属性指向构造函数的原型对象，即prototype</span>
</code></pre>
<p>构造函数的特点：</p>
<ul>
<li>构造函数有原型对象<code class='literal'>prototype</code></li>
<li>构造函数原型对象<code class='literal'>prototype</code>有<code class='literal'>constructor</code>指向构造函数本身</li>
<li>构造函数可以通过原型对象添加方法</li>
<li>构造函数创建的实例对象有<code class='literal'>__proto__</code>指向构造函数的原型对象</li>
</ul>
<h3 id="原型链-1">原型链</h3>
<p>上例通过构造函数创建了<code class='literal'>Star</code>对象，又通过<code class='literal'>new</code>关键字实例化了<code class='literal'>ldh</code>对象，<code class='literal'>ldh</code>对象有个<code class='literal'>__proto__</code>属性，该属性也是一个对象，指向构造函数<code class='literal'>Star</code>的原型对象<code class='literal'>Star.prototype</code>，且这个原型对象也有一个<code class='literal'>__proto__</code>属性，指向<code class='literal'>Object.prototype</code>，对应的构造函数就是<code class='literal'>Object</code>，<code class='literal'>Object.prototype</code>也有一个<code class='literal'>__proto__</code>属性，指向<code class='literal'>null</code></p>
<p><img src="img/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt=""></p>
<ul>
<li>原型对象有一个属性<code class='literal'>constructor</code>指向构造函数：<br><code class='literal'>Star.prototype.constructor</code>指向<code class='literal'>Star</code>，<code class='literal'>ldh.__proto__.constructor</code>指向<code class='literal'>Star</code></li>
</ul>
<p><img src="img/%E5%8E%9F%E5%9E%8B%E9%93%BEproto%E6%8C%87%E5%90%91.png" alt=""></p>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>Object.prototype</code>是所有对象的最顶层，它的<code class='literal'>__proto__</code>属性指向了<code class='literal'>null</code></p>

        </blockquote>
      <blockquote><p><strong>ES6之前通过<em>构造函数</em>和<em>原型</em>实现面向对象编程</strong></p>
</blockquote><h2 id="es5实现继承圣杯模式">es5实现继承(圣杯模式)</h2>
<pre><code class="language-js"><span class="hljs-keyword">var</span> inherit = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {}
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">Target, Origin</span>) {
        F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Origin</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
        <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();
        <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Target</span>;
        <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">uber</span> = <span class="hljs-title class_">Origin</span>;
    }
}())

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-string">&#x27;person&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, grade</span>) {
    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;
}

<span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>);<span class="hljs-comment">//Student继承Person</span>

<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;pp&quot;</span>);
<span class="hljs-keyword">var</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;ss&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(student.<span class="hljs-property">say</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">say</span>);<span class="hljs-comment">//可以访问到父级的say变量</span>
student.<span class="hljs-property">say</span> = <span class="hljs-string">&#x27;student&#x27;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(student.<span class="hljs-property">say</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">say</span>);<span class="hljs-comment">//但是不改变父级的say变量</span>
</code></pre>
<h2 id="函数方法">函数方法</h2>
<h3 id="call">call</h3>
<ul>
<li>作用</li>
</ul>
<p>改变<code class='literal'>this</code>指向</p>
<ul>
<li>示例</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;lll&#x27;</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;---&quot;</span> + (x+y));
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-title function_">call</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<span class="hljs-comment">//lll---3</span>
</code></pre>
<ul>
<li>应用场景</li>
</ul>
<ul>
<li>实现继承</li>
</ul>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>call</code>可以传递参数,第一个参数为一个对象，从第二个参数往后的所有参数会当成函数的实参传入</p>

        </blockquote>
      <h3 id="apply">apply</h3>
<ul>
<li>应用场景</li>
</ul>
<ul>
<li>经常做一些跟数组有关的操作，比如利用<code class='literal'>Math</code>对象的方法找出数组元素的最大最小值</li>
</ul>
<h3 id="bind">bind</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);
btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>;
    }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">3000</span>);
}

<span class="hljs-comment">//多个按钮绑定点击事件？？？</span>
</code></pre>
<ul>
<li>应用场景</li>
</ul>
<ul>
<li>只想改变<code class='literal'>this</code>指向，不想调用函数</li>
</ul>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>call</code>、<code class='literal'>apply</code>会改变<code class='literal'>this</code>指向，且调用函数，而<code class='literal'>bind</code>只会改变<code class='literal'>this</code>指向并不会调用函数，但是它会返回一个已经改变了<code class='literal'>this</code>指向的函数拷贝</p>

        </blockquote>
      <h2 id="数组方法">数组方法</h2>
<h3 id="foreach">forEach</h3>
<p>遍历数组，没有返回值</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
    arr[i] = val*<span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> arr[i];
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [2, 4, 6]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// undefined</span>
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>无法使用<code class='literal'>return</code>、<code class='literal'>break</code>命令中途跳出循环</p>

        </blockquote>
      <h3 id="map">map</h3>
<p>遍历数组，有返回值，返回一个新数组</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> val*<span class="hljs-number">2</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [2, 4, 6]</span>
</code></pre>
<h3 id="filter">filter</h3>
<p>遍历数组，有返回值，将满足条件的数组元素放到一个新数组中返回</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> val%<span class="hljs-number">2</span> !== <span class="hljs-number">0</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [1, 3]</span>
</code></pre>
<h3 id="reduce">reduce</h3>
<p>对数组中的每一个元素执行特定的操作</p>
<pre><code class="language-js"><span class="hljs-comment">//求和数组</span>
<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> c = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">c, v, i</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> c+v;
}, <span class="hljs-number">0</span>)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<span class="hljs-comment">// 9</span>
</code></pre>
<p><code class='literal'>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code></p>
<ul>
<li>callback: 回调函数<ul>
<li>accumulator：它是上一次调用回调时返回的累积值，或initialValue</li>
<li>currentValue：数组中正在处理的元素</li>
<li>index | 可选：数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始</li>
<li>array | 可选：调用reduce()的数组</li>
</ul>
</li>
<li>initialValue | 可选：作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错</li>
</ul>
<ul>
<li>应用场景<ul>
<li>数组求和</li>
<li>对象求和</li>
<li>二维数组转化为一维数组</li>
<li>计算数组中每个元素出现的次数</li>
<li>按属性对<code class='literal'>object</code>分类</li>
<li>数组去重</li>
<li>按顺序运行<code class='literal'>Promise</code></li>
<li>功能性函数管道</li>
<li>使用<code class='literal'>reduce</code>实现<code class='literal'>map</code></li>
</ul>
</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">详细参见MDN吧，还未完全理解</a></p>
<h3 id="some">some</h3>
<p>遍历数组，查找数组中是不是至少有一个符合条件的元素，返回值为<code class='literal'>Boolean</code></p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> flag = arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> val === <span class="hljs-number">2</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flag); <span class="hljs-comment">// true</span>
</code></pre>
<h3 id="every">every</h3>
<p>遍历数组，查找数组中所有元素是否符合条件，返回值为<code class='literal'>Boolean</code></p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> flag = arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">2</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [4, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flag); <span class="hljs-comment">// true</span>
</code></pre>
<blockquote><p><strong>以上为ES5新增的方法↑</strong><br><strong>↓以下为ES6新增的方法</strong></p>
</blockquote><h3 id="from">from</h3>
<p>从一个类数组浅拷贝并返回一个数组</p>
<h3 id="of">of</h3>
<p>创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型</p>
<pre><code class="language-js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">7</span>);       <span class="hljs-comment">// [7] </span>
<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span>

<span class="hljs-title class_">Array</span>(<span class="hljs-number">7</span>);          <span class="hljs-comment">// [ , , , , , , ]</span>
<span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>Array.of()</code>和<code class='literal'>Array</code>构造函数之间的区别在于处理整数参数：<code class='literal'>Array.of(7)</code>创建一个具有单个元素 7 的数组，而<code class='literal'>Array(7)</code>创建一个长度为7的空数组(这是指一个有7个空位(<code class='literal'>empty</code>)的数组，而不是由7个<code class='literal'>undefined</code>组成的数组)</p>

        </blockquote>
      <h3 id="find">find</h3>
<p>遍历数组，返回数组元素中第一个满足条件的元素</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> arr1 = arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">2</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [4, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1); <span class="hljs-comment">// 4</span>
</code></pre>
<h3 id="includes">includes</h3>
<p>遍历数组，判断数组中是否包含一个指定的值，返回值为<code class='literal'>Boolean</code>，有两个参数，第一个参数为要查找的值，第二个参数为下标，从该下标开始查找</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> f1 = arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [4, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f1); <span class="hljs-comment">// true</span>

<span class="hljs-keyword">var</span> f2 = arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f2); <span class="hljs-comment">//false</span>
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>数组对象中<code class='literal'>from</code>、<code class='literal'>isArray</code>、<code class='literal'>of</code>为静态方法，直接通过构造函数调用<code class='literal'>Array.of</code>，其他方法为原型对象上定义的，使用数组实例对象调用<code class='literal'>[].map</code>、<code class='literal'>new Array().forEach</code></p>

        </blockquote>
      <h3 id="iterator">iterator</h3>
<ul>
<li>yield<br>后面跟一个可遍历的结构，它会调用该结构的遍历器接口</li>
</ul>
<h3 id="forof">for...of</h3>
<ol>
<li><p><code class='literal'>for...of</code>循环会自动遍历<code class='literal'>Generator</code>函数运行时生成的<code class='literal'>Iterator</code>对象，且此时不再需要调用<code class='literal'>next</code>方法</p>
</li>
<li><p>遍历的是数组的元素</p>
</li>
</ol>
<h3 id="forin">for...in</h3>
<ul>
<li>几个缺点：<ol>
<li><code class='literal'>for...in</code>遍历的是数组的下标（字符串数字）或对象的键，且会遍历原型链上所有可枚举的键</li>
<li>某些情况下，<code class='literal'>for...in</code>会以任意顺序遍历键名</li>
<li><code class='literal'>for...in</code>主要用来遍历对象而不是数组</li>
</ol>
</li>
</ul>
<h2 id="对象方法">对象方法</h2>
<h3 id="definepropertyobj-prop-descriptor">defineProperty(obj, prop, descriptor)</h3>
<h3 id="assign">assign</h3>
<p>用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> to = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">var</span> so = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: { <span class="hljs-attr">d</span>: <span class="hljs-number">3</span> } };
<span class="hljs-keyword">var</span> res = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(to, so);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// { a: 1, b: 2, c: { d: 3 } }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(to); <span class="hljs-comment">// { a: 1, b: 2, c: { d: 3 } }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(so); <span class="hljs-comment">// { b: 2, c: { d: 3 } }</span>
to.<span class="hljs-property">c</span>.<span class="hljs-property">d</span> = <span class="hljs-number">4</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(to); <span class="hljs-comment">// { a: 1, b: 2, c: { d: 4 } }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(so); <span class="hljs-comment">// { b: 2, c: { d: 4 } }</span>
</code></pre>
<p><strong>注意：1. 如果源对象和目标对象都有相同的属性，则源对象覆盖目标对象；2. 无法实现深拷贝。</strong></p>
<h3 id="freeze">freeze</h3>
<p>冻结对象，使其属性无法被增删改</p>
<h3 id="is">is</h3>
<p>方法判断两个值是否为同一个值。如果满足以下条件则相等：</p>
<ul>
<li>都是 <code class='literal'>undefined</code></li>
<li>都是 <code class='literal'>null</code></li>
<li>都是 <code class='literal'>true</code> 或 <code class='literal'>false</code></li>
<li>都是相同长度的字符串且相同字符按相同顺序排列</li>
<li>都是相同对象（意味着每个对象有同一个引用）</li>
<li>都是数字且<ul>
<li>都是 <code class='literal'>+0</code></li>
<li>都是 <code class='literal'>-0</code></li>
<li>都是 <code class='literal'>NaN</code></li>
<li>或都是非零而且非 <code class='literal'>NaN</code> 且为同一个值</li>
</ul>
</li>
</ul>
<p>与 <code class='literal'>==</code>、 <code class='literal'>===</code> 的区别：</p>
<ul>
<li><code class='literal'>==</code> 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 <code class='literal'>&quot;&quot; == false</code> 判断为 <code class='literal'>true</code>), 而 <code class='literal'>Object.is</code>不会强制转换两边的值；</li>
<li>与 <code class='literal'>===</code> 运算也不相同。 <code class='literal'>===</code> 运算符 (也包括 <code class='literal'>==</code> 运算符) 将数字 <code class='literal'>-0</code> 和 <code class='literal'>+0</code> 视为相等 ，而将 <code class='literal'>Number.NaN</code> 与 <code class='literal'>NaN</code> 视为不相等。</li>
</ul>
<h2 id="字符串方法">字符串方法</h2>
<p><strong>ES6新增方法</strong></p>
<h3 id="startswith">startsWith</h3>
<h3 id="endswith">endsWith</h3>
<h3 id="repeat">repeat</h3>
<h2 id="strict严格模式">strict严格模式</h2>
<p><code class='literal'>&#39;use strict&#39;</code></p>
<p>严格模式下<code class='literal'>this</code>指向问题：</p>
<ul>
<li>全局作用域中函数中的<code class='literal'>this</code>指向<code class='literal'>undefined</code></li>
<li>构造函数不用<code class='literal'>new</code>实例化直接调用，<code class='literal'>this</code>会报错，因为<code class='literal'>this</code>指向<code class='literal'>undefined</code></li>
<li>使用<code class='literal'>new</code>实例化的<code class='literal'>this</code>还是指向实例对象</li>
<li>定时器<code class='literal'>this</code>还是指向<code class='literal'>window</code></li>
<li>事件、对象中的<code class='literal'>this</code>还是指向调用者</li>
</ul>
<h2 id="promise">Promise</h2>
<h3 id="基本语法">基本语法</h3>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>) {
        <span class="hljs-title function_">resolve</span>(resp);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(error);
    }
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
    <span class="hljs-comment">// 成功回调</span>
}, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-comment">// 失败回调</span>
})
</code></pre>
<p>构建<code class='literal'>Promise</code>实例时传入<code class='literal'>function</code>作为参数，该函数参数包含两个参数：<code class='literal'>resolve</code>和<code class='literal'>reject</code>，当异步操作成功时自动调用<code class='literal'>resolve</code>，失败时调用<code class='literal'>reject</code>，通过<code class='literal'>.then</code>定义成功和失败的回调函数</p>
<p>上例也可如下写：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">//...</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
})
</code></pre>
<ul>
<li><p><code class='literal'>Promise</code>有三种状态：</p>
<ol>
<li><code class='literal'>Pending</code>进行中</li>
<li><code class='literal'>Resolved</code>已完成，又称<code class='literal'>Fulfilled</code></li>
<li><code class='literal'>Rejected</code>已失败</li>
</ol>
</li>
<li><p>举例：封装<code class='literal'>ajax</code></p>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url);
        xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;
        xhr.<span class="hljs-title function_">send</span>();
        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) {
                <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);
            }
        };
        xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
          <span class="hljs-title function_">reject</span>();
        }
    })
}

<span class="hljs-comment">// 调用</span>
<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&quot;./data.json&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">message</span>);
})
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>.then</code>中的返回也是一个<code class='literal'>Promise</code>对象，如果人为返回一个非<code class='literal'>Promise</code>对象的类型，则会被自动转化为<code class='literal'>Promise</code>对象，且状态为<code class='literal'>resolve</code><br>如下所示：</p>

        </blockquote>
      <pre><code class="language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">// 12</span>
})

<span class="hljs-comment">//等价于</span>

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">12</span>);
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">// 12</span>
})
</code></pre>
<h3 id="promiseall">Promise.all</h3>
<p>用于将多个<code class='literal'>Promise</code>实例包装成一个新的<code class='literal'>Promise</code>实例</p>
<ul>
<li>基本用法:</li>
</ul>
<p><code class='literal'>var p = Promise.all([p1, p2, p3]);</code></p>

        <blockquote class='explain'>
          <div style='display:flex'>
            <i></i><span class='tips'>说明：</span>
          </div>
          <p><strong></strong>上面代码中，<code class='literal'>Promise.all</code>方法接受一个数组（或类数组）作为参数，<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>都是<code class='literal'>Promise</code>对象的实例，如果不是，就会先调用<code class='literal'>Promise.resolve</code>方法将其转为<code class='literal'>Promise</code>实例，再进一步处理。</p>

        </blockquote>
      <p><code class='literal'>p</code>的状态由<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>决定，分两种情况：</p>
<ol>
<li>只有<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>的状态都变成<code class='literal'>fulfilled</code>，<code class='literal'>p</code>的状态才会变成<code class='literal'>fulfilled</code>，此时<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>的返回值组成一个数组，传递给<code class='literal'>p</code>的回调函数；</li>
<li>只要<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>之中有一个被<code class='literal'>rejected</code>，<code class='literal'>p</code>的状态就变成<code class='literal'>rejected</code>，此时第一个被<code class='literal'>rejected</code>的实例的返回值，会传递给<code class='literal'>p</code>的回调函数</li>
</ol>
<ul>
<li>应用举例</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> promises = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&quot;./&quot;</span> + id + <span class="hljs-string">&quot;.json&quot;</span>);
});

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">datas</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
})
</code></pre>
<h3 id="promiserace">Promise.race</h3>
<p><code class='literal'>Promise.race</code>方法同样是将多个<code class='literal'>Promise</code>实例包装成一个新的<code class='literal'>Promise</code>实例</p>
<ul>
<li>基本用法</li>
</ul>
<p><code class='literal'>var p = Promise.race([p1, p2, p3]);</code></p>

        <blockquote class='explain'>
          <div style='display:flex'>
            <i></i><span class='tips'>说明：</span>
          </div>
          <p><strong></strong>上面代码中，只要<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>之中有一个实例率先改变状态，<code class='literal'>p</code>的状态就跟着改变，且该实例的返回值传递给<code class='literal'>p</code>的回调函数。<code class='literal'>Promise.race</code>的参数如果不是<code class='literal'>Promise</code>实例则会调用<code class='literal'>Promise.resolve</code>将其转为<code class='literal'>Promise</code>实例，再进一步处理。</p>

        </blockquote>
      <ul>
<li>应用举例：请求超时时间</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([
    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&quot;./bigdata.json&quot;</span>),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;请求超时&quot;</span>));
        }, <span class="hljs-number">3000</span>);
    })
]);

p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
})
</code></pre>
<h3 id="promiseresolve">Promise.resolve</h3>
<p><code class='literal'>Promise.resolve</code>方法的参数分成四种情况：</p>
<ul>
<li>参数是一个<code class='literal'>Promise</code>对象</li>
</ul>
<p>如果参数是<code class='literal'>Promise</code>对象，那么<code class='literal'>Promise.resolve</code>不做任何处理，原封不动的返回这个实例</p>
<ul>
<li>参数是一个<code class='literal'>thenable</code>对象</li>
</ul>
<p><code class='literal'>Promise.resolve</code>方法会将这个对象转为<code class='literal'>Promise</code>对象，然后立即执行<code class='literal'>thenable</code>对象的<code class='literal'>then</code>方法</p>
<p><code class='literal'>thenable</code>对象指的是具有<code class='literal'>then</code>方法的对象，如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> thenable = {
    <span class="hljs-attr">then</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>);
    }
}

<span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(thenable);
p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<span class="hljs-comment">//42</span>
});
</code></pre>
<ul>
<li>参数是一个非<code class='literal'>thenable</code>对象，或原始值</li>
</ul>
<p><code class='literal'>Promise.resolve</code>方法返回一个<code class='literal'>Promise</code>实例，状态为<code class='literal'>Resolved</code>且返回值为参数值</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello promise&quot;</span>);

p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<span class="hljs-comment">//hello promise</span>
})
</code></pre>
<ul>
<li>不带任何参数</li>
</ul>
<p><code class='literal'>Promise.resolve</code>方法允许调用时不带参数，直接返回一个<code class='literal'>Resolve</code>状态的<code class='literal'>Promise</code>实例；所以可以使用<code class='literal'>Promise.resolve</code>方法直接创建一个<code class='literal'>Promise</code>实例</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();

<span class="hljs-comment">//等价于</span>

<span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title function_">resolve</span>();
})
</code></pre>
<h3 id="promisereject">Promise.reject</h3>
<p><code class='literal'>Promise.reject</code>方法也会返回一个新的<code class='literal'>Promise</code>实例，该实例状态为<code class='literal'>rejected</code>。它的参数用法与<code class='literal'>Promise.resolve</code>方法完全一致。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();

<span class="hljs-comment">//等价于</span>

<span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(_, <span class="hljs-function"><span class="hljs-params">reject</span> =&gt;</span> {
    <span class="hljs-title function_">reject</span>();
});
</code></pre>
<h3 id="实现finally">实现finally</h3>
<p><code class='literal'>finally</code>方法用于指定不管<code class='literal'>Promise</code>对象最后状态如何都会执行的操作；它接受一个回调函数作为参数，该函数不管怎样都会执行。</p>
<pre><code class="language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-keyword">let</span> P = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(
        <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> P.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> val),
        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> P.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> { <span class="hljs-keyword">throw</span> err })
    );
}

<span class="hljs-comment">//等价于</span>

<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> P = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(
        <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> {
            <span class="hljs-keyword">let</span> p1 = P.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
                <span class="hljs-keyword">return</span> val;
            })
            <span class="hljs-keyword">return</span> p1;
        },
        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
            <span class="hljs-keyword">let</span> p2 = P.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
                <span class="hljs-keyword">throw</span> err;
            })
            <span class="hljs-keyword">return</span> p2;
        }
    );
}
</code></pre>
<h3 id="应用">应用</h3>
<ul>
<li>异步加载图片<pre><code class="language-js"><span class="hljs-keyword">const</span> loadImage = <span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();
      image.<span class="hljs-property">onload</span> = resolve;
      image.<span class="hljs-property">onerror</span> = reject;
      image.<span class="hljs-property">src</span> = url;
  });
}
</code></pre>
</li>
</ul>
<h2 id="宏任务与微任务">宏任务与微任务</h2>
<p>js任务执行流程<br><img src="img/js%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<ul>
<li>同步任务依次进入主线程执行，异步任务进入<code class='literal'>Event Table</code></li>
<li>当异步任务指定的事情完成时，<code class='literal'>Event Table</code>会将回调函数注册到<code class='literal'>Event Queue</code></li>
<li>主线程内的任务执行完之后，会去<code class='literal'>Event Queue</code>读取对应的函数，进入主线程执行</li>
<li>上述过程会不断重复，也就是常说的<code class='literal'>Event Loop</code>(事件循环)</li>
</ul>
<blockquote><p><strong>js引擎存在<code class='literal'>monitoring process</code>进程，不断的检查主线程执行栈是否为空，一旦为空则去<code class='literal'>Event Queue</code>检查是否有等待被调用的函数</strong></p>
</blockquote><h3 id="宏任务macrotask">宏任务(Macrotask)</h3>
<p>包括：I/O、<code class='literal'>setTimeout</code>、<code class='literal'>setInterval</code>、<code class='literal'>requestAnimationFrame</code></p>
<h3 id="微任务microtask">微任务(Microtask)</h3>
<p>包括：<code class='literal'>MutationObserver</code>、<code class='literal'>Promise.then</code>、<code class='literal'>Promise.catch</code></p>
<blockquote><p><strong>任务执行优先级：同步任务 &gt; 微任务 &gt; 宏任务</strong></p>
</blockquote><ul>
<li>举例说明：</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">//同步任务</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
    <span class="hljs-comment">//宏任务</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);
}, <span class="hljs-number">0</span>)

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
    <span class="hljs-comment">//微任务</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);
});

<span class="hljs-comment">//同步任务</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);

<span class="hljs-comment">//控制台输出：</span>
<span class="hljs-comment">//1</span>
<span class="hljs-comment">//4</span>
<span class="hljs-comment">//3</span>
<span class="hljs-comment">//2</span>
</code></pre>
<h2 id="symbol">Symbol</h2>
<h2 id="iterator-1">iterator</h2>
<h2 id="generator函数">Generator函数</h2>
<ul>
<li>基本语法</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">helloGenerator</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;hello&#x27;</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;generator&#x27;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;end&#x27;</span>;
}

<span class="hljs-keyword">var</span> hg = <span class="hljs-title function_">helloGenerator</span>();
</code></pre>
<ul>
<li><p>特性：</p>
<ul>
<li><code class='literal'>Generator</code>函数调用后不会立即执行，而是返回一个遍历器对象(或指针对象)；</li>
<li>只有调用<code class='literal'>Generator</code>函数的<code class='literal'>next</code>方法，才会执行，直到遇到下一个<code class='literal'>yield</code>或<code class='literal'>return</code>；</li>
<li><code class='literal'>yield</code>后面的操作只有在调用的时候才会开始执行</li>
</ul>
</li>
<li><p><code class='literal'>yield</code>与<code class='literal'>return</code>的异同：</p>
<ul>
<li>都能返回跟在语句后的表达式的值；</li>
<li>执行中每遇到<code class='literal'>yield</code>，函数暂停一下，下一个调用<code class='literal'>next</code>再从该位置继续向后执行，而<code class='literal'>return</code>不具备位置记忆功能；</li>
<li>一个函数里面只能执行一次<code class='literal'>return</code>语句，但是可以执行多次<code class='literal'>yield</code>；</li>
<li>普通函数只能返回一次值，因为只能执行一次<code class='literal'>return</code>，<code class='literal'>Generator</code>函数可以返回一系列值，因为可以有任意多个<code class='literal'>yield</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>调用<code class='literal'>next</code>方法的时候可以传入参数，作为上次整个<code class='literal'>yield</code>表达式的返回值；</li>
<li><code class='literal'>yield</code>关键字后跟的语句也会有一个执行结果，该结果会封装成一个对象返回给调用<code class='literal'>next</code>方法的地方：<code class='literal'>{ value: xxx, done: Boolean }</code></li>
</ul>
</li>
</ul>
<p>有点抽象，举例说明：</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;start&quot;</span>);
  <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>+<span class="hljs-number">3</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;p1:&quot;</span>,p1);
  <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">yield</span> <span class="hljs-string">`<span class="hljs-subst">${p1}</span> generator`</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;p2:&quot;</span>,p2);
}

<span class="hljs-keyword">let</span> f = <span class="hljs-title function_">fn</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1:&quot;</span>,f.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2:&quot;</span>,f.<span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;world&quot;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3:&quot;</span>,f.<span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;haha&quot;</span>));

<span class="hljs-comment">//f.next()执行</span>
    <span class="hljs-comment">// start</span>
    <span class="hljs-comment">// 1: {value: 4, done: false}</span>
<span class="hljs-comment">//f.next(&quot;world&quot;)执行</span>
    <span class="hljs-comment">// p1: world</span>
    <span class="hljs-comment">// 2: {value: &quot;world generator&quot;, done: false}</span>
<span class="hljs-comment">//f.next(&quot;haha&quot;)执行</span>
    <span class="hljs-comment">// p2: haha</span>
    <span class="hljs-comment">// 3: {value: undefined, done: true}</span>
</code></pre>
<p>通过上例，</p>
<ol>
<li>第一次调用<code class='literal'>next</code>时，从函数开头执行，直到遇到<code class='literal'>yield</code>关键字，此时开始执行<code class='literal'>yield</code>关键字后的表达式<code class='literal'>1+3</code>，得到结果<code class='literal'>4</code>封装进对象<code class='literal'>value</code>属性，并将结果<code class='literal'>{ value: 4, done: false }</code>返回给调用<code class='literal'>next</code>的地方；指针停留在此处，不再继续执行；</li>
<li>第二次调用<code class='literal'>next</code>时，传入参数值<code class='literal'>world</code>，该参数值作为第一次执行结束指针指向的<code class='literal'>yield</code>表达式<code class='literal'>yield 1+3</code>的返回值返回，即上例中的<code class='literal'>p1</code>接收到该值；函数继续从上次停住的地方(即上次执行结果指针指向的地方)执行，直到遇到下一个<code class='literal'>yield</code>关键字，此时执行该<code class='literal'>yield</code>之后的语句<code class='literal'>${p1} generator</code>，同样该语句执行结果封装到返回对象<code class='literal'>value</code>属性：<code class='literal'>{ value: &quot;world generator&quot;, done: false }</code>返回给调用<code class='literal'>next</code>的地方；指针停留在此处，不再继续执行；</li>
<li>同上，直到函数结尾，此时返回对象中<code class='literal'>done</code>为<code class='literal'>true</code>表示函数执行完成。</li>
</ol>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>next</code>方法传入的参数只会作为上次整个<code class='literal'>yield</code>表达式的返回值，看下例</p>

        </blockquote>
      <pre><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span> * (<span class="hljs-keyword">yield</span> (x + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">var</span> z = <span class="hljs-keyword">yield</span> (y / <span class="hljs-number">3</span>);
  <span class="hljs-keyword">return</span> (x + y + z);
}

<span class="hljs-keyword">var</span> a = <span class="hljs-title function_">foo</span>(<span class="hljs-number">5</span>);
a.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// Object{value:6, done:false}</span>
a.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// Object{value:NaN, done:false}</span>
a.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// Object{value:NaN, done:true}</span>

<span class="hljs-keyword">var</span> b = <span class="hljs-title function_">foo</span>(<span class="hljs-number">5</span>);
b.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// { value:6, done:false }</span>
b.<span class="hljs-title function_">next</span>(<span class="hljs-number">12</span>) <span class="hljs-comment">// { value:8, done:false }</span>
b.<span class="hljs-title function_">next</span>(<span class="hljs-number">13</span>) <span class="hljs-comment">// { value:42, done:true }</span>
</code></pre>
<p>上例中，第二次<code class='literal'>next</code>传入的参数<code class='literal'>12</code>只会作为上次<code class='literal'>yield</code>整个表达式<code class='literal'>yield (x + 1)</code>的返回值，因此<code class='literal'>y</code>的值为<code class='literal'>2 * 12</code>等于<code class='literal'>24</code></p>
<h2 id="async与await">async与await</h2>
<h2 id="reflect">Reflect</h2>
<h2 id="proxy">Proxy</h2>
<h1 id="dom">DOM</h1>
<p>DOM结构树示意图</p>
<p><img src="img/DOM%E7%BB%93%E6%9E%84%E6%A0%91.png" alt="DOM结构树示意图"></p>
<h1 id="事件监听方法">事件监听方法</h1>
<h2 id="封装事件">封装事件</h2>
<blockquote><p>addEventListener<br>attachEvent<br>on+事件类型</p>
</blockquote><pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addEvent</span>(<span class="hljs-params">elem, type, handle</span>) {
    <span class="hljs-keyword">if</span> (elem.<span class="hljs-property">addEventListener</span>) {
        elem.<span class="hljs-title function_">addEventListener</span>(type, handle, <span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elem.<span class="hljs-property">attachEvent</span>) {
        elem.<span class="hljs-title function_">attachEvent</span>(type, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            handle.<span class="hljs-title function_">call</span>(elem);
        });
    } <span class="hljs-keyword">else</span> {
        elem[<span class="hljs-string">&#x27;on&#x27;</span> + type] = handle;
    }
}

<span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];
<span class="hljs-title function_">addEvent</span>(div, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerText</span>);
})
</code></pre>
<h2 id="事件冒泡">事件冒泡</h2>
<blockquote><p>结构上(非视觉上)嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。(自底向上)</p>
</blockquote><h2 id="事件捕获">事件捕获</h2>
<blockquote><p>结构上(非视觉上)嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素(事件源元素)。(自顶向下)</p>
</blockquote><blockquote><p>IE没有捕获事件</p>
</blockquote><blockquote><p>addEventListener函数的最后一位形参为false时，事件冒泡；否则事件捕获。</p>
</blockquote><blockquote><p>如果同一元素同一事件既绑定了事件冒泡又绑定了事件捕获，则先捕获后冒泡</p>
</blockquote><pre><code class="language-xml">// html代码
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;con&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// js代码</span>
<span class="hljs-keyword">var</span> wrap = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;wrap&#x27;</span>)[<span class="hljs-number">0</span>];
<span class="hljs-keyword">var</span> con = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;con&#x27;</span>)[<span class="hljs-number">0</span>];
<span class="hljs-keyword">var</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;box&#x27;</span>)[<span class="hljs-number">0</span>];
<span class="hljs-comment">// 冒泡</span>
wrap.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;wrap 冒泡&#x27;</span>)
}, <span class="hljs-literal">false</span>);
con.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;con 冒泡&#x27;</span>)
}, <span class="hljs-literal">false</span>);
box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;box 冒泡&#x27;</span>)
}, <span class="hljs-literal">false</span>);

<span class="hljs-comment">// 捕获</span>
wrap.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;wrap 捕获&#x27;</span>)
}, <span class="hljs-literal">true</span>);
con.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;con 捕获&#x27;</span>)
}, <span class="hljs-literal">true</span>);
box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;box 捕获&#x27;</span>)
}, <span class="hljs-literal">true</span>);
</code></pre>
<p>当点击box区域时，执行结果如下：</p>
<p><img src="img/%E4%BA%8B%E4%BB%B6_%E6%8D%95%E8%8E%B7_%E5%86%92%E6%B3%A1.png" alt="运行结果"></p>
<blockquote><p>focus,blur,change,submit,reset,select等事件不冒泡</p>
</blockquote><h2 id="取消事件冒泡">取消事件冒泡</h2>
<blockquote><p>W3C标准: e.stopPropagation(); 不支持IE9以下版本</p>
</blockquote><blockquote><p>e.cancelBubble = true; 兼容IE, chrome也支持了该方式</p>
</blockquote><h2 id="阻止默认事件">阻止默认事件</h2>
<blockquote><p>W3C标准: e.preventDefault(); 不支持IE9以下版本</p>
</blockquote><blockquote><p>return false; 只支持elem.onclick/... = function() {}方式注册的事件</p>
</blockquote><blockquote><p>e.returnValue = false; 兼容IE,chrome也支持了该方式</p>
</blockquote><h2 id="事件委托">事件委托</h2>
<p>利用事件冒泡和事件源对象进行处理</p>
<blockquote><p><strong>原理：</strong>给父节点添加事件监听器，利用事件冒泡影响到每一个子节点</p>
</blockquote><p>优点：</p>
<ol>
<li>性能--不需要循环所有的元素一个个绑定事件</li>
<li>灵活--当有新的子元素时不需要重新绑定事件</li>
</ol>
<p>需求：ul下有10个li，要求给每个li添加点击事件，点击li时打印li中的文本信息<br>示例：</p>
<pre><code class="language-html">// html代码
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// js代码</span>
<span class="hljs-keyword">var</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)[<span class="hljs-number">0</span>];
ul.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-keyword">var</span> event = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>,
            target = event.<span class="hljs-property">target</span> || event.<span class="hljs-property">srcElement</span>; <span class="hljs-comment">// target兼容火狐, srcElement兼容IE</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">innerText</span>);
}
</code></pre>
<h1 id="键盘事件">键盘事件</h1>
<blockquote><p>keydown可以检测所有按键，但是无法区分字母大小写</p>
</blockquote><blockquote><p>keypress只能检测字符按键，且能根据ASCII值区分字母</p>
</blockquote><h1 id="贪吃蛇">贪吃蛇</h1>
<p><a href="demo/snake.html">贪吃蛇</a></p>
<h1 id="扫雷">扫雷</h1>
<h1 id="js异步加载">js异步加载</h1>
<h2 id="defer">defer</h2>
<p><code class='literal'>&lt;script src=&quot;tools.js&quot; defer=&#39;defer&#39;&gt;&lt;/script&gt;</code></p>
<p>或</p>
<pre><code class="language-js">&lt;script defer=<span class="hljs-string">&#x27;defer&#x27;</span>&gt;
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;kk&#x27;</span>;
    ...	
&lt;/script&gt;
</code></pre>
<p>整个dom文档解析完成之后，才执行；只支持IE</p>
<h2 id="async">async</h2>
<p><code class='literal'>&lt;script src=&#39;tools.js&#39; async=&#39;async&#39;&gt;&lt;/script&gt;</code></p>
<p>加载完成就执行，W3C标准</p>
<h2 id="动态创建script标签，插入到dom中，实现按需加载js">动态创建script标签，插入到DOM中，实现按需加载js</h2>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncLoadScript</span>(<span class="hljs-params">url, callback</span>) {
    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);
    script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;

    <span class="hljs-keyword">if</span> (script.<span class="hljs-property">readyState</span>) { <span class="hljs-comment">// 兼容IE</span>
        script.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">if</span> (script.<span class="hljs-property">readyState</span> == <span class="hljs-string">&#x27;complete&#x27;</span> || script.<span class="hljs-property">readyState</span> == <span class="hljs-string">&#x27;loaded&#x27;</span>) {
                <span class="hljs-title function_">callback</span>();
            }
        }
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 其他浏览器，如：chrome,firefox等</span>
        script.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-title function_">callback</span>();
        }
    }

    script.<span class="hljs-property">src</span> = url; <span class="hljs-comment">// 此时只下载不执行</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script); <span class="hljs-comment">// 此时执行</span>
}
</code></pre>
<h1 id="js时间线">js时间线</h1>
<p><strong>1. 创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = &#39;loading&#39;。</strong></p>
<p><strong>2. 遇到link外部css，创建线程加载，并继续解析文档。</strong></p>
<p><strong>3. 遇到script外部js，并且没有设置async、defer，浏览器加载并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。</strong></p>
<p><strong>4. 遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()）</strong></p>
<p><strong>5. 遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</strong></p>
<p><strong>6. 当文档解析完成，document.readyState = &#39;interactive&#39;。</strong></p>
<p><strong>7. 文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同，但同样禁止使用document.write()）</strong></p>
<p><strong>8. document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</strong></p>
<p><strong>9. 当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = &#39;complete&#39;，window对象触发load事件。</strong></p>
<p><strong>10. 从此，以异步响应方式处理用户输入、网络事件等。</strong></p>
<h1 id="正则表达式">正则表达式</h1>
<h2 id="正向预查反向预查">正向预查&amp;反向预查</h2>
<h3 id="n">?=n</h3>
<p>匹配字符a并且其后紧跟一个c：<code class='literal'>/a(?=c)/</code></p>
<h3 id="n-1">?!n</h3>
<p>匹配字符a并且其后紧跟的字符不为c：<code class='literal'>/a(?!c)/</code></p>
<h2 id="量词">量词</h2>
<h3 id="n-2">n+</h3>
<p>匹配一个或多个a：<code class='literal'>/a+/</code></p>
<p>匹配一个或多个单词字符：<code class='literal'>/\w+/</code></p>
<h3 id="n-3">n*</h3>
<p>匹配零个或多个a：<code class='literal'>/a*/</code></p>
<p>匹配零个或多个单词字符：<code class='literal'>/\w*/</code></p>
<h3 id="n-4">n?</h3>
<p>匹配零个或一个a：<code class='literal'>/a*/</code></p>
<p>匹配零个或一个单词字符：<code class='literal'>/\w*/</code></p>
<h3 id="nx">n{x}</h3>
<p>匹配3个a：<code class='literal'>/a{3}/</code></p>
<p>匹配3个单词字符：<code class='literal'>/\w{3}/</code></p>
<h3 id="nxy">n{x,y}</h3>
<p>匹配2-3个a：<code class='literal'>/a{2,3}/</code></p>
<p>匹配2-3个单词字符：<code class='literal'>/\w{2,3}/</code></p>
<h3 id="nx-1">n{x,}</h3>
<p>匹配至少2个a：<code class='literal'>/a{2,}/</code></p>
<p>匹配至少2个单词字符：<code class='literal'>/\w{2,}/</code></p>
<h3 id="n-5">n$</h3>
<p>匹配结尾为a的字符：<code class='literal'>/a$/</code></p>
<p>匹配结尾为单词字符的字符：<code class='literal'>/\w$/</code></p>
<h3 id="n-6">^n</h3>
<p>匹配开头为a的字符：<code class='literal'>/^a/</code></p>
<p>匹配开头为单词字符的字符：<code class='literal'>/^\w/</code></p>
<p>匹配以a开头并且以c结尾的字符：<code class='literal'>/^a\w*c$/</code></p>
<h2 id="元字符">元字符</h2>
<h3 id="w">\w</h3>
<p>查找单词字符：[a-zA-Z0-9_]</p>
<h3 id="w-1">\W</h3>
<p>查找非单词字符</p>
<h3 id="d">\d</h3>
<p>查找数字：[0-9]</p>
<h3 id="d-1">\D</h3>
<p>查找非数字字符</p>
<h3 id="s">\s</h3>
<p>查找空白字符(空格、换行等)</p>
<h3 id="s-1">\S</h3>
<p>查找非空白字符</p>
<h3 id="b">\b</h3>
<p>查找单词边界<br>举例：查找a且为单词边界  <code class='literal'>/a\b/</code>, <code class='literal'>&#39;abcda&#39;.match(/a\b/) </code>只会匹配到最后一个字母a</p>
<h3 id="b-1">\B</h3>
<p>查找非单词边界</p>
<h3 id="">.</h3>
<p>查找单个字符，除了换行和行结束符</p>
<h2 id="惰性匹配">惰性匹配</h2>
<blockquote><p>正则表达式遵循<strong>贪婪匹配</strong>原则，即能多匹配就多匹配，如：<code class='literal'>/\d{2,5}/</code>，该表达式能匹配5个就绝对不会匹配2个<br>但是有的时候<strong>贪婪</strong>并不是一件好事，此时就需要<strong>惰性匹配</strong>，如：<code class='literal'>/\d{2,5}?/</code>，该表达式匹配2个之后就不再匹配了</p>
</blockquote><blockquote><p><code class='literal'>&#39;aa111sd&#39;.match(/(\d)+?/g)</code>结果为：<code class='literal'>[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]</code></p>
</blockquote><blockquote><p><code class='literal'>&#39;aa111sd&#39;.match(/(\d)+/g)</code>结果为：<code class='literal'>[&quot;111&quot;]</code></p>
</blockquote><h3 id="惰性匹配情况如下">惰性匹配情况如下</h3>
<p><code class='literal'>{m,n}?</code></p>
<p><code class='literal'>{m,}?</code></p>
<p><code class='literal'>??</code></p>
<p><code class='literal'>*?</code></p>
<p><code class='literal'>+?</code></p>
<h2 id="多选分支">多选分支</h2>
<ol>
<li>匹配&quot;good&quot;和&quot;nice&quot;：<code class='literal'>/good|nice/g</code></li>
<li>需注意：<code class='literal'>&quot;goodbye&quot;.match(/good|goodbye/)</code>结果为：<code class='literal'>[&quot;good&quot;]</code>；若改为<code class='literal'>&quot;goodbye&quot;.match(/goodbye|good/)</code>结果为：<code class='literal'>[&quot;goodbye&quot;]</code></li>
</ol>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>此为惰性匹配,如：<code class='literal'>&quot;#0fbbad&quot;.match(/#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})/)</code>结果为：<code class='literal'>[&quot;#0fb&quot;]</code></p>

        </blockquote>
      <h2 id="非捕获分组：">非捕获分组：<code class='literal'>?:</code></h2>
<p>字符串方法replace中子表达式的运用中介绍到的子表达式可以将当前匹配项捕获到，以便后续引用，因此也称为捕获分组。<br>除了介绍的一些API中使用，还可以用于自身，如下：</p>
<pre><code class="language-js"><span class="hljs-comment">// 匹配日期：yyyy-MM-dd、yyyy/MM/dd、yyyy.MM.dd</span>
<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d{4}(-|\/|\.)\d{2}\1\d{2}/</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2020-01-09&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2020/01/09&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2020.01.09&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2020-01/09&#x27;</span>));
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_%E9%9D%9E%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84_1.png" alt="捕获分组"></p>
<p>如果只想使用括号最原始的功能，后续也不会引用，此时可以使用非捕获分组，如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(ab)+/g</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ababa ab abbaab&#x27;</span>.<span class="hljs-title function_">match</span>(reg));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;捕获分组：$1=&#x27;</span>,<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);

<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(?:ab)+/g</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ababa ab abbaab&#x27;</span>.<span class="hljs-title function_">match</span>(reg));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;非捕获分组：$1=&#x27;</span>,<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_%E9%9D%9E%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84_2.png" alt="非捕获分组"></p>
<h2 id="字符串方法replace中子表达式的运用">字符串方法replace中子表达式的运用</h2>
<blockquote><p>replace的第二个参数可以是字符串，也可以是函数，当是字符串时：<br><code class='literal'>$1,$2...$n</code> 匹配第1-n里捕获的文本<br><code class='literal'>$&amp;</code> 匹配到的字串文本<br>$` 匹配到的字串文本左边的文本<br><code class='literal'>$&#39;</code> 匹配到的字串文本右边的文本<br><code class='literal'>$$</code> 美元符号</p>
</blockquote><pre><code class="language-js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;2,3,4&#x27;</span>;
<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d/g</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27;$&amp;$&amp;$&amp;&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27;$`&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&quot;$&#x27;&quot;</span>));
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_replace_3.png" alt="replace应用"></p>
<h3 id="正则表达式中用可以构建子表达式，可以有多个子表达式，如果需要重复使用同一个子表达式，可通过12获取，表示第12个子表达式">正则表达式中用()可以构建子表达式，可以有多个子表达式，如果需要重复使用同一个子表达式，可通过$1,$2...获取，表示第1,2...个子表达式</h3>
<ol>
<li>将the_first_name改为小驼峰式: theFirstName<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/_(\w)/g</span>;
<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;the_first_name&#x27;</span>.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span>(<span class="hljs-params">$, $<span class="hljs-number">1</span></span>) {
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($, $<span class="hljs-number">1</span>);
 <span class="hljs-keyword">return</span> $<span class="hljs-number">1.</span><span class="hljs-title function_">toUpperCase</span>();
})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
</code></pre>
<img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_replace_1.png" alt="replace应用"></li>
</ol>
<blockquote><p>如图所示，replace的第二个参数可以是一个回调函数，该函数有多个形参，第一个形参为匹配项，后面的形参为子表达式匹配值；replace会用该函数的返回值作为替换值去替换匹配到的字符</p>
</blockquote><p>上例，若如下写：</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/_(\w)/g</span>;
<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;the_first_name&#x27;</span>.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>.<span class="hljs-title function_">toUpperCase</span>();
})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
</code></pre>
<p>运行会发现结果不尽人意：<code class='literal'>&quot;theNirstName&quot;</code><br>修改上述问题代码，控制台打印时间戳，看是否每匹配到一次就执行一次回调，若如此则不应出现上述错误</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/_(\w)/g</span>;
<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;the_first_name&#x27;</span>.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>());
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>.<span class="hljs-title function_">toUpperCase</span>();
})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
</code></pre>
<p>运行结果如下：</p>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_replace_2.png" alt="replace应用"></p>
<p>由此可见，匹配到几次就会执行几次回调函数，但是执行时间是在所有匹配结束之后统一回调的。</p>
<h2 id="字符串方法split注意项">字符串方法split注意项</h2>
<h3 id="可以有第二个参数，表示结果数组的最大长度">可以有第二个参数，表示结果数组的最大长度</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;html,css,javascript&#x27;</span>;
<span class="hljs-keyword">var</span> arr = str.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/,/</span>, <span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_split_1.png" alt=""></p>
<h3 id="结果数组中可以包含分隔符">结果数组中可以包含分隔符</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;html,css,javascript&#x27;</span>;
<span class="hljs-keyword">var</span> arr = str.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/(,)/</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_split_2.png" alt=""></p>
<h2 id="实战">实战</h2>
<h3 id="1-将100000000000改为100000000000-即从最后一位数字开始-每倒数三位用--分隔">1. 将100000000000改为100.000.000.000, 即从最后一位数字开始, 每倒数三位用 . 分隔</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(\B)(?=((\d){3})+$)/g</span>;

<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;100000000000&#x27;</span>.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27;.&#x27;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_1.png" alt="实战1"></p>
<blockquote><p><code class='literal'>/(?!^)(?=((\d){3})+$)/g</code>也可以实现上述功能</p>
</blockquote><h3 id="2-匹配24进制时间：010-920-30-50-9">2. 匹配24进制时间：<code class='literal'>/^([01][0-9]|[2][0-3]):[0-5][0-9]$/</code></h3>
<h3 id="3-同上，区别是0202可以是22：00-910-920-300-91-50-9">3. 同上，区别是02:02可以是2:2：<code class='literal'>^(0?[0-9]|1[0-9]|2[0-3]):(0?[0-9]|[1-5][0-9])$</code></h3>
<h3 id="4-匹配日期：d4-01-910-2-01-9120-9301">4. 匹配日期：<code class='literal'>/^\d{4}-(0?[1-9]|1[0-2])-(0?[1-9]|[12][0-9]|3[01])$/</code></h3>
<h3 id="5-密码校验：16位，2由数字和大小写字母组成，3至少含有数字和小写字母">5. 密码校验：1.6位，2.由数字和大小写字母组成，3.至少含有数字和小写字母</h3>
<pre><code class="language-js"><span class="hljs-comment">// 至少含有数字和小写字母</span>
/((?=.*[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])(?=.*[a-z]))^[<span class="hljs-number">0</span>-9a-zA-Z]{<span class="hljs-number">6</span>}$/g

<span class="hljs-comment">// 至少含有两种字符，方式一</span>
/((?=.*[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])(?=.*[a-z])|(?=.*[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[<span class="hljs-number">0</span>-9A-<span class="hljs-title class_">Za</span>-z]{<span class="hljs-number">6</span>,<span class="hljs-number">12</span>}$/

<span class="hljs-comment">// 至少含有两种字符，方式二</span>
<span class="hljs-regexp">/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/</span>
</code></pre>
<h1 id="css">CSS</h1>
<h2 id="盒子模型">盒子模型</h2>
<ul>
<li>包括：<code class='literal'>content</code>(内容区)、<code class='literal'>padding</code>(内边距)、<code class='literal'>border</code>(边框)、<code class='literal'>margin</code>(外边距)</li>
<li>一般浏览器<code class='literal'>content</code>不包含<code class='literal'>padding</code>和<code class='literal'>border</code>，但<code class='literal'>IE</code>不然</li>
<li>可以使用<code class='literal'>box-sizing: border-box;</code>设置为<code class='literal'>content</code>包含<code class='literal'>padding</code>和<code class='literal'>border</code></li>
</ul>
<h2 id="元素分类">元素分类</h2>
<ul>
<li>块级元素：<code class='literal'>ul</code>、<code class='literal'>ol</code>、<code class='literal'>li</code>、<code class='literal'>dl</code>、<code class='literal'>dd</code>、<code class='literal'>h1-6</code>、<code class='literal'>p</code>、<code class='literal'>section</code>、<code class='literal'>div</code>、<code class='literal'>form</code>、<code class='literal'>address</code>、<code class='literal'>center</code>(居中)、<code class='literal'>hr</code>、<code class='literal'>pre</code>(预格式化)、<code class='literal'>blockquote</code>(文本缩进)、<code class='literal'>marquee</code>(文本滚动)、<code class='literal'>table</code></li>
<li>行内元素：<code class='literal'>a</code>、<code class='literal'>b</code>(加粗)、<code class='literal'>span</code>、<code class='literal'>img</code>、<code class='literal'>input</code>、<code class='literal'>select</code>、<code class='literal'>textarea</code>、<code class='literal'>em</code>(斜体)、<code class='literal'>strong</code>、<code class='literal'>br</code>、<code class='literal'>sup</code>()上标、<code class='literal'>sub</code>(下标)、<code class='literal'>i</code>(斜体)、<code class='literal'>del</code>(删除线)、<code class='literal'>u</code>(下划线)</li>
</ul>
<h2 id="居中">居中</h2>
<pre><code class="language-css"><span class="hljs-comment">/*1.设置父元素弹性布局*/</span>
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">display</span>:flex;
    <span class="hljs-attribute">justify-content</span>: center;
    <span class="hljs-attribute">align-items</span>: center;
}
</code></pre>
<p><a href="./%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E5%B1%85%E4%B8%AD.html">点我看效果</a></p>
<pre><code class="language-css"><span class="hljs-comment">/*2*/</span>
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>;
}
</code></pre>
<pre><code class="language-css"><span class="hljs-comment">/*3*/</span>
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);
}
</code></pre>
<pre><code class="language-css"><span class="hljs-comment">/*4*/</span>
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">margin</span>: auto;
}
</code></pre>
<h2 id="css获取容器宽高的方式">css获取容器宽高的方式</h2>
<ol>
<li>el.offsetWidth = width + 左右padding + 左右border</li>
<li>el.clientWidth = width + 左右padding</li>
<li>el.scrollWidth = 实际高度(可视区高度+隐藏区高度)，包括padding但不包含border</li>
</ol>
<h2 id="chrome等浏览器表单提交记住密码后，下次自动填充表单的背景会变成黄色，修改方法">chrome等浏览器表单提交记住密码后，下次自动填充表单的背景会变成黄色，修改方法</h2>
<pre><code><span class="hljs-comment">//方法1</span>
<span class="hljs-attr">input</span>:-webkit-autofill, <span class="hljs-attr">textarea</span>:-webkit-autofill, <span class="hljs-attr">select</span>:-webkit-autofill {
  background-<span class="hljs-attr">color</span>: #fff;<span class="hljs-comment">//设置成元素原本的颜色</span>
  background-<span class="hljs-attr">image</span>: none;
  <span class="hljs-attr">color</span>: <span class="hljs-title function_">rgb</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}
<span class="hljs-comment">//方法2</span>
<span class="hljs-attr">input</span>:-webkit-autofill {
    -webkit-box-<span class="hljs-attr">shadow</span>: 0px <span class="hljs-number">0</span> 3px 100px #ccc inset; <span class="hljs-comment">//背景色</span>
}
</code></pre>
<h2 id="变形动画">变形动画</h2>
<ol>
<li><code class='literal'>transform:translateX(100px) translateY(100px) translateZ(100px) translate(10px, 10px) translate3d(10px, 20px, 20px);</code>平移,Z轴不能使用百分数</li>
<li><code class='literal'>transform:rotateX(45deg) rotate(45deg, 90deg) rotate3d(90deg, 20deg, 30deg);</code>旋转</li>
<li><code class='literal'>transform:scaleX(.5) scale(.5, 2) scale3d(.5, 2, 1.5);</code>缩放</li>
<li><code class='literal'>transform:skewX(45deg) skew(45deg, 60deg);</code>倾斜</li>
<li><code class='literal'>transform-origin:left top 100px;</code>参考点</li>
<li><code class='literal'>backface-visiability:visible/hidden;</code>旋转后背面是否可见,需父级设置<code class='literal'>transform-style: preserve-3d</code></li>
<li><code class='literal'>transform-style:preserve-3d;</code>3d效果</li>
<li><code class='literal'>background:linear-gradient(45deg, red, green 50%, blue 30%);</code>背景颜色线性渐变</li>
<li><code class='literal'>background:radial-gradient(45deg, red, green, blue);</code>径向渐变</li>
</ol>
<h2 id="过渡效果">过渡效果</h2>
<ol>
<li><code class='literal'>transition-property: background,width/all/none;</code>需要过渡的属性</li>
<li><code class='literal'>transition-duration: 2s/1s, 200ms;</code>过渡时间,当设置的过渡属性个数多于过渡时间个数时,第一个属性匹配第一个时间,依次类推;当匹配到最后一个时间时,剩余属性再次从第一个时间开始匹配,依次循环匹配,直至最后属性。</li>
<li><code class='literal'>transition-timing-function: ease/ease-in/ease-out/ease-in-out/linear/cubic-bezier(n,n,n,n);</code>设置过渡效果</li>
<li><code class='literal'>transition-delay: 1s;</code>可设置多值,当设置的过渡属性个数多于该属性个数时,匹配规则同<code class='literal'>transition-duration</code></li>
<li><code class='literal'>transition: all linear 2s 1s;</code>依次为：过渡属性 过渡效果 过渡时间 过渡延时,可设多值：<code class='literal'>width ease 2s 200ms, background linear 1s 1s</code>;</li>
</ol>
<h2 id="动画">动画</h2>
<ol>
<li><code class='literal'>animation-name: xx,yy;</code>动画名称,可设置多个</li>
<li><code class='literal'>animation-duration: 2s,3s;</code>动画时间,当动画设置个数多于动画时间时,匹配规则同<code class='literal'>transition-duration</code></li>
<li><code class='literal'>animation-iteration-count: 1;</code>动画执行次数,可设置动画个数多于该设置时,匹配规则同<code class='literal'>transition-duration</code>;另该值为:<code class='literal'>infinite</code>时动画执行无限次</li>
<li><code class='literal'>animation-direction: normal/reverse/alternate/alternate-reverse;</code>动画方向,始于第一帧(或最后一帧),停止于初始帧,如果执行次数(<code class='literal'>animation-iteration-count</code>)等于1,从第一帧(或最后一帧)平滑过渡到最后一帧(或第一帧),然后跳回初始帧;如果执行次数(<code class='literal'>animation-iteration-count</code>)大于等于2,则有多种情况-&gt;<code class='literal'>normal</code>:从第一帧平滑过渡到最后一帧,然后跳回第一帧再平滑过渡到最后一帧,依此循环执行,直至结束停在初始帧;<code class='literal'>alternate</code>:从第一帧平滑过渡到最后一帧,然后从最后一帧平滑过渡到第一帧,再从第一帧平滑过渡到最后一帧,依此循环执行,直至结束停在初始帧;<code class='literal'>reverse</code>:从最后一帧平滑过渡到第一帧,然后跳回最后一帧再次平滑过渡到第一帧,依此循环执行,直至动画结束停在初始帧;<code class='literal'>alternate-reverse</code>:从最后一帧平滑过渡到第一帧,然后从第一帧平滑过渡到最后一帧,再从最后一帧平滑过渡到第一帧,依此循环执行直至动画结束停在初始帧;具体效果参考:<a href="demo/animation-direction.html">animation-direction案例</a>。</li>
<li><code class='literal'>animation-delay: 2s;</code>动画延时执行</li>
<li><code class='literal'>animation-fill-mode: none/forwards/backwards/both;</code>设置动画执行前后的状态,<code class='literal'>none</code>:始于第一帧,终于初始帧;<code class='literal'>forwards</code>:始于第一帧,终于最后帧;<code class='literal'>backwards</code>:始于第一帧,终于初始帧(不是第一帧);<code class='literal'>both</code>:始于第一帧,终于最后一帧;默认始于初始帧,终于初始帧;具体效果参考:<a href="demo/animation-fill-mode.html">animation-fill-mode案例</a>。</li>
<li><code class='literal'>animation-play-state: running/paused;</code>动画状态运行or暂停</li>
<li><code class='literal'>animation-timing-function:ease/ease-in/ease-out/ease-in-out/linear/steps;</code>动画执行节奏,始于第一帧,停止于初始帧;<code class='literal'>ease</code>(默认):从第一帧开始,逐渐加速然后减速终于最后一帧,停止于初始帧;<code class='literal'>ease-in</code>:从第一帧开始,前一半时间慢速移动,后一半时间快速移动终于最后一帧,停止于初始帧;<code class='literal'>ease-out</code>:从第一帧开始,前一半时间快速移动,后一半时间慢速移动终于最后一帧,停止于初始帧;<code class='literal'>ease-in-out</code>:从第一帧开始,两头慢速移动,中间快速移动终于最后一帧,停止于初始帧;<code class='literal'>linear</code>:从第一帧开始匀速移动终于最后一帧,停止于初始帧;<code class='literal'>step-start</code>:开始时直接从第一帧跳到最后一帧等待动画结束,停止于初始帧,如果动画执行多次,则第一次执行跳到最后一帧后不再动,直至动画执行结束停止于初始帧,等同于<code class='literal'>steps(1,start);step-end</code>:动画执行一次时,动画执行结束的最后一刻直接跳到最后一帧,停止于初始帧,如果动画执行多次,则一直不动,等同于<code class='literal'>steps(1,end);steps(n,start)</code>:n&gt;=2,第一帧和最后一帧之间分n等份执行,停止于初始帧;<code class='literal'>steps(n,end)</code>:第一帧和最后一帧之间分n等份,在第一帧与n-1帧之间执行,开始时等待(执行时间/n)s,然后开始执行,停止于初始帧;也可使用贝塞尔曲线：<code class='literal'>cubic-bezier(n,n,n,n)</code>,自定义<a href="https://cubic-bezier.com">贝塞尔曲线</a>;具体效果参考:<a href="demo/animation-timing-function.html">animation-timing-function案例</a>。</li>
<li><code class='literal'>@keyframes xx { 25% {...} 50% {...} ...}</code>定义动画</li>
</ol>
<h2 id="弹性布局">弹性布局</h2>
<ol>
<li><code class='literal'>display:flex;</code>弹性盒模型</li>
<li><code class='literal'>flex-wrap:nowrap/wrap/wrap-reverse;</code>子元素超出父元素时的显示,<code class='literal'>warp</code>换行或换列显示;<code class='literal'>nowrap</code>不换行/列(默认);<code class='literal'>wrap-reverse</code>反向换行/列</li>
<li><code class='literal'>flex-direction:row/row-reverse/column/column-reverse;</code>布局方向,<code class='literal'>column</code>按列,<code class='literal'>row</code>按行</li>
<li><code class='literal'>flex-flow:column wrap;</code>2,3综合体</li>
<li><code class='literal'>justify-content: flex-start/flex-end/center/space-between/space-around/space-evenly;</code>主轴排列方式</li>
<li><code class='literal'>align-items: stretch(默认)/center/flex-start/flex-end;</code>交叉轴排列方式</li>
<li><code class='literal'>align-content: stretch/flex-start/flex-end/center/space-between/space-around/space-evenly;</code>只适用于多行显示的弹性容器，它的作用是当flex容器在交叉轴上有多余的空间时，对元素的对齐处理</li>
<li><code class='literal'>align-self:stretch/flex-start/flex-end/center;</code>控制单个元素在交叉轴上的排列方式</li>
<li><code class='literal'>flex-grow:1;</code>将弹性盒子的可用空间，分配给弹性元素。可以使用整数或小数声明</li>
<li><code class='literal'>flex-shrink: 2;</code>弹性盒子装不下元素时定义的缩小值</li>
<li><code class='literal'>flex-basis: 100px;</code>分配多余空间之前，项目占据的主轴空间,优先级<code class='literal'>width/height &lt; flex-basis &lt; min/max-width/height</code></li>
<li><code class='literal'>flex:1 0 100px;</code>9、10、11综合体</li>
<li><code class='literal'>order: 1;</code>控制弹性元素的排序,数值越小越在前面，可以负数或整数</li>
</ol>
<h2 id="栅格系统">栅格系统</h2>
<ol>
<li><code class='literal'>display:grid/inline-grid;</code>设置元素为块级/行级栅格容器</li>
<li><code class='literal'>grid-template-rows:100px 100px;</code>划分行,有<code class='literal'>100px 100px、50% 50%、repeat(2, 50%)、repeat(2, 1fr)、repeat(2, 100px)</code>等多种写法</li>
<li><code class='literal'>grid-template-columns:25% 25% 25% 25%;</code>划分列,写法同上</li>
<li><code class='literal'>row-grap: 20px;</code>设置行间距</li>
<li><code class='literal'>column-grap: 30px;</code>设置列间距</li>
<li><code class='literal'>grap: 20px 30px;</code>4,5组合</li>
</ol>
<h2 id="将iconfont图标以unicode的方式引入项目">将iconfont图标以Unicode的方式引入项目</h2>
<ol>
<li>将图标添加到购物车</li>
</ol>
<h1 id="vue">vue</h1>
<h2 id="过滤器filter">过滤器filter</h2>
<h3 id="全局过滤器">全局过滤器</h3>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(filter_name, <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;11&quot;</span>;
});
</code></pre>
<p>调用：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ name | filter_name }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="可传参">可传参</h4>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(filter_name, <span class="hljs-keyword">function</span>(<span class="hljs-params">value, args1, args2</span>) {});
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ name | filter_name(&#x27;args1&#x27;, &#x27;args2&#x27;) }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="可同时使用多个过滤器">可同时使用多个过滤器</h4>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ name | filter_name | filter_name }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>前一个过滤器的返回值会做为后一个过滤器的第一个参数值传入</p>
<p><strong>注意：</strong>过滤器只能用于：双花括号插值和<code class='literal'>v-bind</code>表达式</p>
<h2 id="自定义指令directive">自定义指令directive</h2>
<h3 id="全局指令">全局指令</h3>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(directive_name, {
    <span class="hljs-title function_">bind</span>(<span class="hljs-params"></span>) {},								<span class="hljs-comment">//只调用一次,指令第一次绑定到元素时;一般样式操作写这</span>
    <span class="hljs-title function_">inserted</span>(<span class="hljs-params"></span>) {},						<span class="hljs-comment">//被绑定元素插入父节点时调用;js行为写这</span>
    <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {},              <span class="hljs-comment">//所在组件更新时调用</span>
    <span class="hljs-title function_">componentUpdated</span>(<span class="hljs-params"></span>) {},		<span class="hljs-comment">//所在组件VNode及其子VNodes全部更新时调用</span>
    <span class="hljs-title function_">unbind</span>(<span class="hljs-params"></span>) {}								<span class="hljs-comment">//只调用一次,指令与元素解绑时</span>
})
</code></pre>
<p>第一个参数为指令名称,<strong>注意：</strong>指令在调用时,必须加<code class='literal'>v-</code>前缀<br>第二个参数是一个对象,包含各个阶段的钩子函数<br>钩子函数第一个参数为绑定指令的元素,第二个参数为一个对象,对象有以下属性：</p>
<ol>
<li><code class='literal'>name</code>:指令名</li>
<li><code class='literal'>value</code>:指令的绑定值</li>
<li><code class='literal'>oldValue</code>:旧值</li>
<li><code class='literal'>expression</code>:字符串形式的指令表达式</li>
<li><code class='literal'>arg</code>:传给指令的参数，可选。例如 <code class='literal'>v-my-directive:foo</code> 中，参数为 <code class='literal'>&quot;foo&quot;</code></li>
<li><code class='literal'>modifiers</code>:一个包含修饰符的对象。例如：<code class='literal'>v-my-directive.foo.bar</code> 中，修饰符对象为 <code class='literal'>{ foo: true, bar: true }</code></li>
</ol>
<h3 id="私有指令">私有指令</h3>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
    <span class="hljs-attr">data</span>:...
    <span class="hljs-attr">methods</span>:...
    <span class="hljs-attr">directives</span>: {
        <span class="hljs-attr">directive_name</span>: {
            <span class="hljs-title function_">bind</span>(<span class="hljs-params"></span>) {},
            <span class="hljs-comment">//...</span>
        },
        <span class="hljs-attr">directive_name2</span>:<span class="hljs-comment">//...可以定义多个</span>
    }
});
</code></pre>
<h3 id="简写">简写</h3>
<p>如果指令只用到<code class='literal'>bind</code>和<code class='literal'>update</code>,则可：</p>
<pre><code class="language-js"><span class="hljs-attr">directives</span>: {
    <span class="hljs-attr">directive_name</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">el, binding</span>) {
        <span class="hljs-comment">//...</span>
    }
}
</code></pre>
<p>以上相当于把代码写到<code class='literal'>bind</code>和<code class='literal'>update</code>钩子函数中</p>
<h2 id="定义子组件">定义子组件</h2>
<h3 id="方式一">方式一</h3>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;child-one&#x27;</span>, {			<span class="hljs-comment">// 子组件名称也可为驼峰式:childOne, html代码调用还是&lt;child-one&gt;</span>
    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h1&gt;{{name}}&lt;/h1&gt;&#x27;</span>,
    data () {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;liuh&#x27;</span>
        }
    },
    <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">age</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>
        }
    }
})
</code></pre>
<p>使用</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child-one</span> <span class="hljs-attr">:age</span>=<span class="hljs-string">&#x27;12&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-one</span>&gt;</span>
</code></pre>
<h3 id="方式二">方式二</h3>
<pre><code class="language-js"><span class="hljs-comment">//定义组件模板</span>
&lt;script type=<span class="hljs-string">&quot;text/x-component&quot;</span> id=<span class="hljs-string">&#x27;contentOne&#x27;</span>&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{name}}-{{age}}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
&lt;/script&gt;
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">//定义组件</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;childOne&#x27;</span>, {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#contentOne&#x27;</span>,
  data () {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;liuh&#x27;</span>
    }
  },
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">age</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>
    }
  }
    
})
</code></pre>
<p>使用</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child-one</span> <span class="hljs-attr">:age</span>=<span class="hljs-string">&#x27;12&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-one</span>&gt;</span>
</code></pre>
<blockquote><p>使用<code class='literal'>Vue.component</code>定义的组件为全局组件</p>
</blockquote><h3 id="方式三私有组件">方式三&lt;私有组件&gt;</h3>
<pre><code class="language-js"><span class="hljs-comment">//组件模板同方式二</span>
<span class="hljs-comment">//定义组件对象</span>
<span class="hljs-keyword">var</span> childOne = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#contentOne&#x27;</span>,
  data () {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;liuh&#x27;</span>
    }
  },
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">age</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>
    }
  }
}

<span class="hljs-comment">//使用此方式定义的组件，需要如下引用</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">components</span>: {childOne}, <span class="hljs-comment">//此处引用子组件</span>
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">m</span>: <span class="hljs-string">&#x27;hello&#x27;</span>
  }
});
</code></pre>
<h3 id="组件模板的定义">组件模板的定义</h3>
<h4 id="使用script标签">使用script标签</h4>
<p>上述例子就是使用<code class='literal'>script</code>标签定义的组件模板，此处不再赘述</p>
<h4 id="使用template标签">使用template标签</h4>
<pre><code>&lt;template id=<span class="hljs-string">&quot;contentOne&quot;</span>&gt;
    <span class="hljs-comment">//模板代码</span>
&lt;/template&gt;
</code></pre>
<h2 id="父子组件通信">父子组件通信</h2>
<h3 id="使用emit">使用$emit</h3>
<pre><code class="language-js"><span class="hljs-comment">// 当子组件发生某些操作时,通过$emit方法,触发监听事件,然后调用父组件的方法对父组件进行操作</span>
<span class="hljs-comment">// 子组件</span>
<span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;calc&#x27;</span>);
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child-one</span> <span class="hljs-attr">:good-list</span>=<span class="hljs-string">&quot;goods&quot;</span> @<span class="hljs-attr">calc</span>=<span class="hljs-string">&#x27;calcPrice()&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-one</span>&gt;</span>
</code></pre>
<p>上述，<code class='literal'>calcPrice</code>为父组件方法</p>
<p>详细见:<a href="demo/vue-$emit.html">父子组件通信之$emit</a></p>
<h3 id="使用sync">使用sync</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child-one</span> <span class="hljs-attr">:good-list.sync</span>=<span class="hljs-string">&quot;goods&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-one</span>&gt;</span>
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>goods</code>为引用变量,sync关键字对普通变量无效</p>

        </blockquote>
      <p>详见:<a href="demo/vue-sync.html">父子组件通信之sync</a></p>
<h2 id="内容分发之slot">内容分发之slot</h2>
<p>俗称：插槽</p>
<h3 id="使用场景">使用场景</h3>
<p>当同一组数据展现的方式不相同时，可以使用插槽</p>
<h3 id="slot使用">slot使用</h3>
<h4 id="260以下版本">2.6.0以下版本</h4>
<pre><code class="language-html">// 子组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span> //具名插槽
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 父组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;parent&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;header&#x27;</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;footer&#x27;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 渲染后
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="260版本">2.6.0版本</h4>
<blockquote><p><code class='literal'>v-slot</code>一般情况下只能添加在<code class='literal'>&lt;template&gt;</code>上</p>
</blockquote><pre><code class="language-html">// 子组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span> //具名插槽
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 父组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;parent&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 渲染后
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h3 id="作用域插槽">作用域插槽</h3>
<p>父组件使用子组件数据</p>
<h4 id="260以下版本-1">2.6.0以下版本</h4>
<pre><code class="language-html">// 子组件,其中list为子组件作用域下定义的变量
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slot1&quot;</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 父组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;parent&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;slot1&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in props.list&quot;</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="260版本-1">2.6.0版本</h4>
<pre><code class="language-html">// 子组件,其中list为子组件作用域下定义的变量
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slot1&quot;</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 父组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;parent&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-slot:slot1</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in props.list&quot;</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="具名插槽缩写">具名插槽缩写</h4>
<p><code class='literal'>v-slot:</code>简写为<code class='literal'>#</code>, 如：<code class='literal'>&lt;template v-slot:slot1=&#39;props&#39;&gt;&lt;/template&gt;</code>可简写为：<code class='literal'>&lt;template #slot1=&#39;props&#39;&gt;&lt;/template&gt;</code></p>
<h2 id="动态组件之is">动态组件之is</h2>
<p><code class='literal'>&lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;</code></p>
<p>当<code class='literal'>type</code>的取值变化时，显示对应的子组件</p>
<blockquote><p>可以不使用<code class='literal'>template</code>标签，使用<code class='literal'>div</code>等标签也可以达到效果</p>
</blockquote><h3 id="keep-alive">keep-alive</h3>
<p>正常情况下，动态组件之间切换时会重新加载组件实例，如果希望组件实例在第一次创建的时候缓存下来，则可以使用<code class='literal'>&lt;keep-alive&gt;</code>标签将动态标签包裹起来</p>
<h3 id="动态组件添加动画效果">动态组件添加动画效果</h3>
<p>动态组件之间切换的时候也可以通过<code class='literal'>&lt;transition&gt;</code>添加过渡动画</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;type=&#x27;login&#x27;&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;type=&#x27;register&#x27;&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;out-in&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;type&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.v-enter</span>, <span class="hljs-selector-class">.v-leave-to</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">150px</span>);
}
<span class="hljs-selector-class">.v-enter-active</span>, <span class="hljs-selector-class">.v-leave-active</span> {
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;
}
</code></pre>
<p>其中，属性<code class='literal'>mode</code>为过渡模式：</p>
<ol>
<li><code class='literal'>out-in</code>:当前元素先过渡离开，完成之后新元素再过渡进入</li>
<li><code class='literal'>in-out</code>:新元素先过渡进入，完成之后当前元素再过渡离开</li>
</ol>
<h2 id="过渡动画">过渡&amp;动画</h2>
<h3 id="transition-group">transition-group</h3>
<p>当需要给<code class='literal'>v-for</code>循环的元素动画时，使用<code class='literal'>transition-group</code></p>
<pre><code>&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;name in person&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>
        {{ name }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
&lt;/div&gt;

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">person</span>: [<span class="hljs-string">&#x27;落樱&#x27;</span>, <span class="hljs-string">&#x27;高山&#x27;</span>, <span class="hljs-string">&#x27;流水&#x27;</span>]
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;小草&#x27;</span>);
    }
  }
});
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.v-enter</span>, <span class="hljs-selector-class">.v-leave-to</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">80px</span>);
}
<span class="hljs-selector-class">.v-enter-active</span>, <span class="hljs-selector-class">.v-leave-active</span> {
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;
}
</code></pre>
<h3 id="appear属性">appear属性</h3>
<p>页面初始化时的入场动画</p>
<h3 id="tag属性">tag属性</h3>
<p>没有该属性时，<code class='literal'>transition-group</code>会被渲染为<code class='literal'>span</code>标签，如果不想被渲染为<code class='literal'>span</code>标签，则使用<code class='literal'>tag</code>属性指定想要被渲染为的标签元素，如：<code class='literal'>&lt;transition-group tag=&quot;ul&quot;&gt;</code></p>
<h3 id="动态组件和路由都可以添加动画">动态组件和路由都可以添加动画</h3>
<pre><code>&lt;transition&gt;
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span>&gt;
&lt;/transition&gt;
</code></pre>
<h2 id="自定义指令">自定义指令</h2>
<h2 id="refs属性">$refs属性</h2>
<p>当需要获取dom元素时，可以使用<code class='literal'>ref</code></p>
<pre><code>&lt;div ref=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;我是一个div&lt;/div&gt;

<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myDiv</span>.<span class="hljs-property">innerText</span>; <span class="hljs-comment">//我是一个div</span>
</code></pre>
<p><code class='literal'>ref</code>属性也可以使用在组件身上</p>
<pre><code>&lt;my-component ref=<span class="hljs-string">&quot;myc&quot;</span>&gt;&lt;/my-component&gt;

<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myc</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">//name是组件my-component的数据(定义在组件data)</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myc</span>.<span class="hljs-title function_">func</span>(); <span class="hljs-comment">//func是组件my-component的方法(定义在组件methods)</span>
</code></pre>
<h2 id="watch侦听器">watch侦听器</h2>
<p><code class='literal'>watch</code>可以监听<code class='literal'>data</code>中定义的变量，如果被监听的变量值发生变化，则会触发相应的方法，该方法有两个参数：第一个参数为新值，第二个参数为旧值</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    <span class="hljs-attr">fullName</span>: <span class="hljs-string">&#x27;&#x27;</span>
  },
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-title function_">firstName</span>(<span class="hljs-params">newVal</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = newVal + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;
    },
    <span class="hljs-attr">lastName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + newVal;
    }
  }
});
</code></pre>
<h2 id="computed计算属性">computed计算属性</h2>
<p><code class='literal'>computed</code>计算属性是一个<code class='literal'>function</code>，该<code class='literal'>function</code>内部会用到<code class='literal'>data</code>中的变量，当这些变量值发生变化时，会触发计算属性（即计算属性定义时的<code class='literal'>function</code>执行）重新计算该属性的值</p>
<p><strong>注意：</strong></p>
<ol>
<li>计算属性可以当成一个<code class='literal'>data</code>中的变量调用</li>
<li>计算属性有缓存机制，若其用到的变量的值没有发生变化，则不会再次计算<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">data</span>: {
 <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;&#x27;</span>,
 <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;&#x27;</span>
  },
  <span class="hljs-attr">computed</span>: {
 <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
   <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;
 }
 <span class="hljs-comment">//简写</span>
 <span class="hljs-comment">//fullName() {</span>
 <span class="hljs-comment">//  return this.firstName + &#x27;-&#x27; + this.lastName;</span>
 <span class="hljs-comment">//}</span>
  }
});
</code></pre>
</li>
</ol>
<h2 id="mvvm响应式原理">MVVM响应式原理</h2>
<h3 id="原理图">原理图</h3>
<p><img src="img/MVVM%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt=""></p>
<h3 id="实现">实现</h3>
<h2 id="路由之vue-router">路由之vue-router</h2>
<pre><code class="language-js"><span class="hljs-comment">// 定义两个组件：hello liuh</span>
<span class="hljs-keyword">const</span> hello = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h3&gt;hello&lt;/h3&gt;&#x27;</span>
};
<span class="hljs-keyword">const</span> liuh = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;liuh&lt;/div&gt;&#x27;</span>
};

<span class="hljs-comment">// 定义路由</span>
<span class="hljs-keyword">let</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/hello&#x27;</span>, <span class="hljs-attr">component</span>: hello },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/liuh&#x27;</span>, <span class="hljs-attr">component</span>: liuh }
];
<span class="hljs-keyword">let</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({
  routes
});

<span class="hljs-comment">// 路由引入</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  router
});
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/hello&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/liuh&quot;</span>&gt;</span>liuh<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h3 id="vue-router之参数传递">vue-router之参数传递</h3>
<p><code class='literal'>:id</code></p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/hello/:id&#x27;</span>, <span class="hljs-attr">component</span>: hello },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/liuh&#x27;</span>, <span class="hljs-attr">component</span>: liuh }
];
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> hello = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;&lt;h3&gt;hello{{$route.params.id}}&lt;/h3&gt;&lt;button @click=&quot;show&quot;&gt;参数&lt;/button&gt;&lt;/div&gt;&#x27;</span>,
  <span class="hljs-attr">methods</span>: {
    show () {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>)
    }
  }
};
</code></pre>
<p>在html代码中使用:<code class='literal'>{{$route.params.id}}</code><br>在js代码中使用:<code class='literal'>this.$route.params.id</code></p>
<p>多个参数时<code class='literal'>...path: &#39;/hello/:id/:name&#39;...</code></p>
<h3 id="vue-router之参数类型限制">vue-router之参数类型限制</h3>
<p><code class='literal'>:id(\\d{2})</code></p>
<p>配合正则表达式限制传递参数的类型</p>
<p><code class='literal'>{ path: &#39;/hello/:id(\\d{2})/:name&#39;, component: hello },</code></p>
<h3 id="重定向redirect">重定向redirect</h3>
<pre><code class="language-js">{ <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">redirect</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-attr">params</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span> } } }
</code></pre>
<p>点击路由:<code class='literal'>about</code>时,会自动重定向到:<code class='literal'>content/3</code></p>
<h3 id="别名alias">别名alias</h3>
<p><code class='literal'>path: &#39;/content/2&#39;, alias: [&#39;/ct2&#39;]</code></p>
<p>路由<code class='literal'>/ct2</code>时,将跳转到<code class='literal'>/content/2</code></p>
<h3 id="命名视图">命名视图</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> header = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h3&gt;header&lt;h3&gt;&#x27;</span>
}

<span class="hljs-keyword">var</span> leftBox = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;left&lt;/div&gt;&#x27;</span>
}

<span class="hljs-keyword">var</span> mainBox = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;main&lt;/div&gt;&#x27;</span>
}

<span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({
  <span class="hljs-attr">routes</span>: [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">components</span>: {
      <span class="hljs-attr">default</span>: header,
      <span class="hljs-attr">left</span>: leftBox,
      <span class="hljs-attr">main</span>: mainBox
    } }
  ]
});

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  router
});
</code></pre>
<h2 id="vue状态管理之vuex">vue状态管理之vuex</h2>
<h3 id="vuex之state">vuex之state</h3>
<pre><code class="language-js"><span class="hljs-keyword">let</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({
    <span class="hljs-attr">state</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;liuh&#x27;</span>
    }
});

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
    store
});
</code></pre>
<p>引用：<code class='literal'>this.$store.state.name</code></p>
<h3 id="vuex之getters">vuex之getters</h3>
<h3 id="vuex之mutations">vuex之mutations</h3>
<h3 id="vuex之actions">vuex之actions</h3>
<h3 id="vuex之modules">vuex之modules</h3>
<h2 id="nrm">nrm</h2>
<h3 id="安装">安装</h3>
<p><code class='literal'>npm i nrm -g</code></p>
<h3 id="作用">作用</h3>
<p>管理npm镜像，可以自由在各种镜像之间切换</p>
<h3 id="查看当前镜像">查看当前镜像</h3>
<p><code class='literal'>nrm ls</code>列表中前面带 “*” 号为当前使用</p>
<h3 id="切换">切换</h3>
<p><code class='literal'>nrm use taobao</code>切换到淘宝镜像</p>
<h1 id="webpack">webpack</h1>
<h2 id="安装-1">安装</h2>
<p>全局安装</p>
<p><code class='literal'>npm install webpack -g</code></p>
<p><code class='literal'>npm i webpack -g</code>	--简写</p>
<p>局部安装</p>
<p><code class='literal'>npm install webpack --save-dev</code></p>
<p><code class='literal'>npm i webpack -D</code>   --简写</p>
<p><code class='literal'>npm i webpack-cli -D</code></p>
<h2 id="项目初始化">项目初始化</h2>
<p><code class='literal'>npm init -y</code></p>
<h2 id="编译单个文件">编译单个文件</h2>
<p><code class='literal'>npx webpack ./src/main.js -o ./dist/boundle.js</code></p>
<p>文件<code class='literal'>main.js</code>将被编译打包到<code class='literal'>dist/boundle.js</code></p>
<h2 id="webpack-dev-server">webpack-dev-server</h2>
<p>项目自动打包编译工具</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i webpack-dev-server -D</code></p>
<p>由于是局部安装，故无法直接执行相应指令进行打包，需要在<code class='literal'>package.json</code>文件中添加配置项: </p>
<pre><code class="language-json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><p>一些配置  </p>
<ol>
<li><code class='literal'>hot</code>热重载</li>
<li><code class='literal'>port</code>设置端口</li>
<li><code class='literal'>contentBase</code>项目启动后打开页面的根目录，若不设置默认打开项目安装目录下index.html</li>
<li><code class='literal'>open</code>启动后自动打开浏览器</li>
</ol>
<ul>
<li><p>方式一：直接在启动命令添加</p>
<p>  <code class='literal'>webpack-dev-server --open --port 8008 --hot --contentBase ../</code></p>
</li>
<li><p>方式二：在webpack配置文件<code class='literal'>webpack.config.js</code>中添加配置</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-attr">devServer</span>: {
  <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//自动打开浏览器</span>
  <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">//启动端口</span>
  <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;./&#x27;</span>,  <span class="hljs-comment">//启动项目的根目录，启动时默认打开当前目录下的index.html</span>
  <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">//是否开启热重载，当开启时，还需要引入热重载插件</span>
}
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>其中，<code class='literal'>hot: true</code>只开启了热重载开关，若要实现真正的功能还需引入热重载插件，该插件为webpack自带</p>

        </blockquote>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>)

<span class="hljs-attr">plugins</span>: [
  <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>()
]
</code></pre>
<h2 id="html-webpack-plugin">html-webpack-plugin</h2>
<p>根据指定的模板html页面自动生成页面，写入内存；且将编译后的脚本文件使用<code class='literal'>script</code>标签导入该页面。</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i html-webpack-plugin -D</code></p>
<ul>
<li>配置</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)

<span class="hljs-attr">plugins</span>: [
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({
    <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./index.html&#x27;</span>),<span class="hljs-comment">//作为模板的html文件路径</span>
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.html&#x27;</span> <span class="hljs-comment">//生成到内存中的文件名称</span>
  })
]
</code></pre>
<ul>
<li><p>参数</p>
<ul>
<li>template：作为模板的html文件路径</li>
<li>filename：生成到内存中的文件名称</li>
<li>title：生成的html页面title</li>
</ul>
</li>
</ul>
<blockquote><p>详见:<a href="https://github.com/jantimon/html-webpack-plugin#configuration">htmlWebpackPlugin插件参数</a></p>
</blockquote><h2 id="css-loader与style-loader">css-loader与style-loader</h2>
<p>webpack只能编译<code class='literal'>.js</code>文件，如果项目中引入<code class='literal'>.css</code>文件(如：<code class='literal'>import &#39;./css/index.css&#39;</code>)，则需要安装<code class='literal'>style-loader</code>和<code class='literal'>css-loader</code></p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i style-loader css-loader -D</code></p>
<ul>
<li>配置</li>
</ul>
<p>webpack配置文件的<code class='literal'>module</code>&gt;<code class='literal'>rules</code>节点添加一个规则:</p>
<pre><code class="language-js"><span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [
    { <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>] }
  ]
}
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>规则配置的loader从右向左调用</p>

        </blockquote>
      <h2 id="less-loader与sass-loader">less-loader与sass-loader</h2>
<p>处理<code class='literal'>.less</code>类型的样式文件</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i less less-loader -D</code></p>
<ul>
<li>配置</li>
</ul>
<pre><code class="language-js"><span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [
    { <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;less-loader&#x27;</span>] }
  ]
}
</code></pre>
<h2 id="url-loader">url-loader</h2>
<p>项目中引入图片等文件的处理</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i file-loader url-loader -D</code></p>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>其中，<code class='literal'>file-loader</code>为<code class='literal'>url-loader</code>的依赖</p>

        </blockquote>
      <ul>
<li>配置</li>
</ul>
<pre><code class="language-js"><span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [{ 
      	<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpg|png)/</span>, 
      	<span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span> 
      }
  ]
}
</code></pre>
<ul>
<li>参数<ul>
<li>limit：<code class='literal'>file-loader</code>默认会将图片处理为Base64格式的字符串，若不想这么处理，则需该参数；配置该参数后，只会将图片大小（单位：byte）小于参数值的图片进行Base64处理</li>
<li>name：<code class='literal'>file-loader</code>处理后的文件名默认使用32位hash值命名，以防重名文件导致的问题；配置该参数值后，会按照配置规则生成文件名</li>
</ul>
</li>
</ul>
<blockquote><p><code class='literal'>{ test: /\.(jpg|png)/, use: &#39;url-loader?limit=110845&amp;name=[hash:8][name].[ext]&#39; }</code>：其中<code class='literal'>limit=110845</code>表示只会对大小小于110845byte的图片进行Base64加密为字符串；<code class='literal'>[hash:8][name]</code>表示图片名称以8位hash+原图片名拼接，<code class='literal'>[ext]</code>表示使用原图片后缀。<br>上述，等价于：</p>
</blockquote><pre><code class="language-js">{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpg|png)$/</span>,
  <span class="hljs-attr">use</span>: [
    {
      <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">limit</span>: <span class="hljs-number">110845</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;[hash:8][name].[ext]&#x27;</span>
      }
    }
  ]
}
</code></pre>
<h2 id="babel-loader">babel-loader</h2>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i babel-loader @babel/core -D</code></p>
<ul>
<li>配置</li>
</ul>
<pre><code class="language-js"><span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [
    {
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
      <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
      <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>
    }
  ]
}
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>其中，<code class='literal'>exclude</code>过滤掉不需要<code class='literal'>babel</code>编译的<code class='literal'>js</code>文件</p>

        </blockquote>
      <h3 id="babel-plugin-transform-runtime">babel-plugin-transform-runtime</h3>
<p><code class='literal'>babel</code>对一些公共方法使用了非常小的辅助代码，比如<code class='literal'>_extend</code>。默认情况下会被添加到每一个需要它的文件中，为了避免重复引入，<code class='literal'>babel</code>引入<code class='literal'>babel-plugin-transform-runtime</code>并且使所有辅助代码从这里引用。</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i @babel/plugin-transform-runtime -D</code></p>
<ul>
<li>配置<ul>
<li><p>方式一：在<code class='literal'>babel</code>配置文件<code class='literal'>.babelrc</code>中添加配置</p>
<pre><code>{
<span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;@babel/transform-runtime&quot;</span>]
}
</code></pre>
</li>
<li><p>方式二：在<code class='literal'>webpack</code>配置文件<code class='literal'>webpack.config.js</code>中添加规则时</p>
<pre><code>{
<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
<span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
<span class="hljs-attr">use</span>: {
    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,
    <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;@babel/transform-runtime&#x27;</span>]
    }
}
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="babel-preset-env">babel-preset-env</h3>
<p>该预设允许你使用最新的<code class='literal'>js</code>，它会将<code class='literal'>es6</code>的语法转换为浏览器识别的语法</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i @babel/preset-env -D</code></p>
<ul>
<li>配置<ul>
<li><p>方式一：在<code class='literal'>babel</code>配置文件<code class='literal'>.babelrc</code>中添加配置</p>
<pre><code>{
<span class="hljs-string">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>]
}
</code></pre>
</li>
<li><p>方式二：在<code class='literal'>webpack</code>配置文件<code class='literal'>webpack.config.js</code>中添加规则时</p>
<pre><code>{
<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
<span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
<span class="hljs-attr">use</span>: {
    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,
    <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]
    }
}
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="webpack中使用vue">webpack中使用vue</h2>
<h3 id="引入vue">引入vue</h3>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i vue -D</code></p>
<p>安装后就可以使用<code class='literal'>vue</code>语法，首先第一步使用<code class='literal'>import</code>引入<code class='literal'>vue</code>包</p>
<ul>
<li>引入</li>
</ul>
<p><code class='literal'>import Vue from &#39;vue&#39;</code></p>
<ul>
<li>使用</li>
</ul>
<pre><code><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
    <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;111&#x27;</span>
    }
})
</code></pre>
<p>项目启动正常，但发现浏览器控制台报错：</p>
<p><img src="img/webpack%E5%BC%95%E5%85%A5vue%E6%8A%A5%E9%94%99-runtime-only.png" alt="webpack引入vue报错"></p>
<blockquote><p><strong>使用<code class='literal'>import</code>引入模块时的原理：</strong></p>
<ol>
<li>项目根目录下查找<code class='literal'>node_modules</code>目录；</li>
<li><code class='literal'>node_modules</code>目录下查找<code class='literal'>from</code>后以字符串值为名的目录，比如：<code class='literal'>vue</code>；</li>
<li>该目录则为引入模块的根目录，在该目录下查找<code class='literal'>package.json</code>，并查找名为<code class='literal'>main</code>的配置项；</li>
<li><code class='literal'>main</code>配置项的值即导入的依赖包。</li>
</ol>
</blockquote>
        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>以上仅为存在<code class='literal'>node_modules</code>目录的情况。</p>

        </blockquote>
      <p>综上所述，查看<code class='literal'>vue</code>模块根目录下<code class='literal'>package.json</code>中配置项<code class='literal'>main</code>的值：</p>
<p><img src="img/vue-package.josn-main.png" alt=""></p>
<p>对比<code class='literal'>vue.runtime.common.js</code>与<code class='literal'>vue.js</code>文件大小：</p>
<p><img src="img/vue.js%E4%B8%8Evue.runtime.common.js%E5%A4%A7%E5%B0%8F%E5%AF%B9%E6%AF%94.png" alt=""></p>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>截图所示<code class='literal'>vue.runtime.common.dev.js</code>为开发环境下的<code class='literal'>vue.runtime.common.js</code>依赖包</p>

        </blockquote>
      <p><img src="img/vue.runtime.common.js%E8%AF%A6%E6%83%85.png" alt=""></p>
<p><strong>重点：</strong><code class='literal'>webpack</code>中使用<code class='literal'>import Vue from &#39;vue&#39;</code>引入<code class='literal'>vue</code>依赖包时，引入的<code class='literal'>vue.runtime.common.js</code>并非完整的<code class='literal'>vue</code>，导致了上述的报错。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>修改配置文件<code class='literal'>package.json</code>：<code class='literal'>&quot;main&quot;: &quot;dist/vue.js&quot;</code>；</li>
<li>引入模块时使用完整路径：<code class='literal'>import Vue from &#39;../node_modules/vue/dist/vue.js&#39;</code>；</li>
<li><code class='literal'>webpack.config.js</code>添加别名配置。<strong>（推荐）</strong></li>
</ol>
<p>上述第三种解决方式的详细配置如下：</p>
<pre><code><span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: {
        <span class="hljs-attr">vue$</span>: <span class="hljs-string">&#x27;vue/dist/vue.js&#x27;</span>
    }
}
</code></pre>
<blockquote><ul>
<li><code class='literal'>resolve</code>与<code class='literal'>entry</code>同级；</li>
<li><code class='literal'>vue$</code>为正则，精确匹配<code class='literal'>import * from &#39;xx&#39;</code>引入时的<code class='literal'>xx</code>值，必须以<code class='literal'>vue</code>结尾才能匹配</li>
</ul>
</blockquote><h3 id="vue-loader">vue-loader</h3>
<p>当使用<code class='literal'>.vue</code>文件进行组件开发时，就需要引入<code class='literal'>vue-loader</code></p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i vue-template-compiler vue-loader -D</code></p>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>vue-template-compiler</code>为<code class='literal'>vue-loader</code>的内部依赖</p>

        </blockquote>
      <ul>
<li>配置</li>
</ul>
<p>修改配置文件：<code class='literal'>webpack.config.js</code></p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">VueLoaderPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-loader&#x27;</span>)
<span class="hljs-comment">//或</span>
<span class="hljs-comment">//const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)</span>

<span class="hljs-comment">//......</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    <span class="hljs-comment">//......</span>
    <span class="hljs-attr">module</span>: {
        <span class="hljs-attr">rules</span>: [
            {
                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>,
                <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;vue-loader&#x27;</span>
            }
        ]
    },
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueLoaderPlugin</span>()
    ]
}
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>VueLoaderPlugin</code>这个插件是<em><strong>必须的</strong></em>，它的职责是将你定义过的其它规则复制并应用到<code class='literal'>.vue</code>文件里相应语言的块。例如，如果你有一条匹配<code class='literal'>/\.js$/</code>的规则，那么它会应用到<code class='literal'>.vue</code>文件里的<code class='literal'>&lt;script&gt;</code>块。</p>

        </blockquote>
      <ul>
<li>使用</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./login.vue&#x27;</span>

<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;111&#x27;</span>
  },
  <span class="hljs-comment">// render: function(createElement) {</span>
  <span class="hljs-comment">//   return createElement(login)</span>
  <span class="hljs-comment">// }</span>
  <span class="hljs-attr">components</span>: {
    login
  }
})
</code></pre>
<p>页面如何使用子组件见<code class='literal'>vue</code>部分，此处不再赘述。</p>
<p>详见：<a href="https://vue-loader.vuejs.org/zh/">Vue Loader API</a></p>
<h1 id="es6">ES6</h1>
<h2 id="class-类">class 类</h2>
<ul>
<li><p>class的本质是<code class='literal'>function</code></p>
</li>
<li><p>class可以看做是构造函数的另一种实现</p>
</li>
<li><p>类也具备构造函数的特点：</p>
</li>
</ul>
<ul>
<li>构造函数有原型对象<code class='literal'>prototype</code></li>
<li>构造函数原型对象<code class='literal'>prototype</code>有<code class='literal'>constructor</code>指向构造函数本身</li>
<li>构造函数可以通过原型对象添加方法</li>
<li>构造函数创建的实例对象有<code class='literal'>__proto__</code>指向构造函数的原型对象</li>
</ul>
<h2 id="promise-1">Promise</h2>

2022-04-18 23:32:02 info - node server started at port 1229
2022-04-18 23:32:04 info - code:<h1 id="ecmascript1">ECMAScript1</h1>
<blockquote><p>基本JavaScript</p>
</blockquote><h2 id="原始数据类型">原始数据类型</h2>
<p><code class='literal'>undefined</code>、<code class='literal'>null</code>、<code class='literal'>Boolean</code>、<code class='literal'>String</code>、<code class='literal'>Number</code>、<code class='literal'>Symbol</code></p>
<h2 id="引用数据类型">引用数据类型</h2>
<p><code class='literal'>Function</code>、<code class='literal'>Object</code></p>
<h2 id="字符串方法汇总">字符串方法汇总</h2>
<h3 id="padstartnumber-fill">padStart(number, fill)</h3>
<p>补全字符串,第一个参数为补全后的字符串长度,第二个参数为用来补的字符</p>
<h4 id="示例">示例</h4>
<pre><code class="language-js"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2020/04/02&quot;</span>);
<span class="hljs-keyword">var</span> year = date.<span class="hljs-title function_">getFullYear</span>();
<span class="hljs-keyword">var</span> month = date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> day = date.<span class="hljs-title function_">getDate</span>();

<span class="hljs-keyword">var</span> dateStr = <span class="hljs-string">`<span class="hljs-subst">${year}</span>-<span class="hljs-subst">${month}</span>-<span class="hljs-subst">${day}</span>`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dateStr);<span class="hljs-comment">//2020-4-2</span>

month = month.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);
day = day.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;0&quot;</span>);

<span class="hljs-keyword">var</span> dateStr2 = <span class="hljs-string">`<span class="hljs-subst">${year}</span>-<span class="hljs-subst">${month}</span>-<span class="hljs-subst">${day}</span>`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dateStr2);<span class="hljs-comment">//2020-04-02</span>
</code></pre>
<h3 id="padendnumber-fill">padEnd(number, fill)</h3>
<p>功能大致同padStart,区别是在原字符串的末尾补全</p>
<blockquote><p>高级JavaScript</p>
</blockquote><h2 id="预编译">预编译</h2>
<h3 id="全局的代码预编译">全局的代码预编译</h3>
<ol>
<li>创建GO(global object)对象</li>
<li>找变量声明，将变量名作为GO对象的属性名，值为undefined</li>
<li>找函数声明，将函数名作为GO对象的属性名，值为函数体</li>
</ol>
<h3 id="函数体中代码预编译函数执行时">函数体中代码预编译(函数执行时)</h3>
<ol>
<li>创建AO(activation object)对象</li>
<li>找变量声明和形参，将变量名和形参名作为AO对象的属性名，值为undefined</li>
<li>实参值和形参统一，即将实参值赋给形参</li>
<li>找函数声明，将函数名作为AO对象的属性名，值为函数体</li>
</ol>
<h2 id="三种区分一个变量是object类型还是array类型的方法">三种区分一个变量是Object类型还是Array类型的方法</h2>
<h3 id="1使用instanceof">1.使用instanceof</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {},
    arr = [];
<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj is Object&quot;</span>);
}
<span class="hljs-keyword">if</span> (arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr is Array&quot;</span>);
}
</code></pre>
<p><img src="img/%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AFObject%E8%BF%98%E6%98%AFArray%E4%B9%8Binstanceof.png" alt="运行结果"></p>
<blockquote><p>当变量arr是数组时，使用：arr instanceof Object 语句得到的结果仍然是true</p>
</blockquote><h3 id="2使用constructor">2.使用constructor</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {},
    arr = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">constructor</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">constructor</span>);
</code></pre>
<p><img src="img/%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AFObject%E8%BF%98%E6%98%AFArray%E4%B9%8Bconstructor.png" alt="运行结果"></p>
<h3 id="3使用call调用object的tostring">3.使用call调用Object的toString()</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {},
    arr = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(arr));
</code></pre>
<p><img src="img/%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AFObject%E8%BF%98%E6%98%AFArray%E4%B9%8BtoString.png" alt="运行结果"></p>
<h2 id="闭包的四种用法">闭包的四种用法</h2>
<h3 id="1实现公有变量">1.实现公有变量</h3>
<pre><code class="language-js"><span class="hljs-comment">//累加器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getCounter</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        count ++;
        <span class="hljs-keyword">return</span> count;
    }
}
<span class="hljs-keyword">var</span> counter = <span class="hljs-title function_">getCounter</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>());
</code></pre>
<h3 id="2可以做缓存">2.可以做缓存</h3>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cache</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">incre</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> ++i;
        },
        <span class="hljs-attr">decre</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> --i;
        }
    }
}
<span class="hljs-keyword">var</span> cache = <span class="hljs-title function_">cache</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">incre</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-title function_">decre</span>());
</code></pre>
<h3 id="3可以实现封装，属性私有化">3.可以实现封装，属性私有化</h3>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;de&#x27;</span>, <span class="hljs-number">19</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>, p.<span class="hljs-property">age</span>);
</code></pre>
<h3 id="4模块化开发，防止污染全局变量">4.模块化开发，防止污染全局变量</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> initC = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {

    <span class="hljs-keyword">var</span> name, age;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">initContent</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">//...</span>
    }
    <span class="hljs-comment">//...</span>

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">initContent</span>();
    }

    }())

<span class="hljs-keyword">var</span> initD = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {

    <span class="hljs-keyword">var</span> name, age;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">initContent</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">//...</span>
    }
    <span class="hljs-comment">//...</span>

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">initContent</span>();
    }

    }())

<span class="hljs-comment">//程序入口</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">initC</span>();
    <span class="hljs-title function_">initD</span>();
    <span class="hljs-comment">//...</span>
}
</code></pre>
<h2 id="数组去重">数组去重</h2>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];
<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">unique</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> obj = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) {
        obj[<span class="hljs-variable language_">this</span>[i]] = <span class="hljs-variable language_">this</span>[i];
    }
    <span class="hljs-keyword">var</span> narr = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) {
        narr.<span class="hljs-title function_">push</span>(key);
    }
    <span class="hljs-keyword">return</span> narr;
}
</code></pre>
<h2 id="深度拷贝">深度拷贝</h2>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">tar, ori</span>) {
    <span class="hljs-keyword">var</span> origin = ori || {};
    <span class="hljs-keyword">var</span> toStr = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> tar) {
        <span class="hljs-keyword">if</span> (toStr.<span class="hljs-title function_">call</span>(tar[key]) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>) {
            origin[key] = [];
            <span class="hljs-title function_">clone</span>(tar[key], origin[key]);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (toStr.<span class="hljs-title function_">call</span>(tar[key]) === <span class="hljs-string">&#x27;[object Object]&#x27;</span>) {
            origin[key] = {};
            <span class="hljs-title function_">clone</span>(tar[key], origin[key]);
        } <span class="hljs-keyword">else</span> {
            origin[key] = tar[key];
        }
    }
    <span class="hljs-keyword">return</span> origin;
}

<span class="hljs-comment">//举例</span>
<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hh&#x27;</span>,
    <span class="hljs-attr">skill</span>: [
        { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;say&#x27;</span> },
        {
            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;11&#x27;</span>
        }
    ]
}
<span class="hljs-keyword">var</span> nobj = <span class="hljs-title function_">clone</span>(obj);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nobj.<span class="hljs-property">skill</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span> === obj.<span class="hljs-property">skill</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>);
</code></pre>
<h3 id="对象的深度拷贝">对象的深度拷贝</h3>
<p>使用<code class='literal'>JSON.stringify</code>将对象序列化，然后再使用<code class='literal'>JSON.parse</code>反序列化</p>
<h2 id="原型链">原型链</h2>
<h3 id="构造函数">构造函数</h3>
<ul>
<li><p>构造函数是一个首字母大写的特殊的<code class='literal'>function</code></p>
</li>
<li><p>每一个构造函数都有一个<code class='literal'>prototype</code>属性，指向另一个对象</p>
</li>
<li><p>原型是一个对象，也称<code class='literal'>prototype</code>为原型对象，它可以实现方法的共享，节省内存空间</p>
</li>
<li><p>每一个实例都有一个<code class='literal'>__proto__</code>属性，该属性指向构造函数的原型对象</p>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">//构造函数首字母大写</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Star</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sing</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我会唱歌&quot;</span>);
    }
}

<span class="hljs-keyword">let</span> ldh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&quot;刘德华&quot;</span>);
<span class="hljs-keyword">let</span> zxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&quot;张学友&quot;</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh.<span class="hljs-property">sing</span> === zxy.<span class="hljs-property">sing</span>);<span class="hljs-comment">//false,此时两个实例对象ldh和zxy的sing方法分别指向两个不同的引用</span>

<span class="hljs-title class_">Star</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">dance</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我会跳舞&quot;</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh.<span class="hljs-property">dance</span> === zxy.<span class="hljs-property">dance</span>);<span class="hljs-comment">//true,此时两个实例对象ldh和zxy的dance方法指向同一个引用，因此可以通过将一些共有方法绑定到构造函数的原型上来实现共享，节省内存空间</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Star</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">//true，每个对象都有一个__proto__属性，该属性指向构造函数的原型对象，即prototype</span>
</code></pre>
<p>构造函数的特点：</p>
<ul>
<li>构造函数有原型对象<code class='literal'>prototype</code></li>
<li>构造函数原型对象<code class='literal'>prototype</code>有<code class='literal'>constructor</code>指向构造函数本身</li>
<li>构造函数可以通过原型对象添加方法</li>
<li>构造函数创建的实例对象有<code class='literal'>__proto__</code>指向构造函数的原型对象</li>
</ul>
<h3 id="原型链-1">原型链</h3>
<p>上例通过构造函数创建了<code class='literal'>Star</code>对象，又通过<code class='literal'>new</code>关键字实例化了<code class='literal'>ldh</code>对象，<code class='literal'>ldh</code>对象有个<code class='literal'>__proto__</code>属性，该属性也是一个对象，指向构造函数<code class='literal'>Star</code>的原型对象<code class='literal'>Star.prototype</code>，且这个原型对象也有一个<code class='literal'>__proto__</code>属性，指向<code class='literal'>Object.prototype</code>，对应的构造函数就是<code class='literal'>Object</code>，<code class='literal'>Object.prototype</code>也有一个<code class='literal'>__proto__</code>属性，指向<code class='literal'>null</code></p>
<p><img src="img/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt=""></p>
<ul>
<li>原型对象有一个属性<code class='literal'>constructor</code>指向构造函数：<br><code class='literal'>Star.prototype.constructor</code>指向<code class='literal'>Star</code>，<code class='literal'>ldh.__proto__.constructor</code>指向<code class='literal'>Star</code></li>
</ul>
<p><img src="img/%E5%8E%9F%E5%9E%8B%E9%93%BEproto%E6%8C%87%E5%90%91.png" alt=""></p>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>Object.prototype</code>是所有对象的最顶层，它的<code class='literal'>__proto__</code>属性指向了<code class='literal'>null</code></p>

        </blockquote>
      <blockquote><p><strong>ES6之前通过<em>构造函数</em>和<em>原型</em>实现面向对象编程</strong></p>
</blockquote><h2 id="es5实现继承圣杯模式">es5实现继承(圣杯模式)</h2>
<pre><code class="language-js"><span class="hljs-keyword">var</span> inherit = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {}
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">Target, Origin</span>) {
        F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Origin</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
        <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();
        <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Target</span>;
        <span class="hljs-title class_">Target</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">uber</span> = <span class="hljs-title class_">Origin</span>;
    }
}())

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-string">&#x27;person&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, grade</span>) {
    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;
}

<span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>);<span class="hljs-comment">//Student继承Person</span>

<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;pp&quot;</span>);
<span class="hljs-keyword">var</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;ss&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(student.<span class="hljs-property">say</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">say</span>);<span class="hljs-comment">//可以访问到父级的say变量</span>
student.<span class="hljs-property">say</span> = <span class="hljs-string">&#x27;student&#x27;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(student.<span class="hljs-property">say</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">say</span>);<span class="hljs-comment">//但是不改变父级的say变量</span>
</code></pre>
<h2 id="函数方法">函数方法</h2>
<h3 id="call">call</h3>
<ul>
<li>作用</li>
</ul>
<p>改变<code class='literal'>this</code>指向</p>
<ul>
<li>示例</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;lll&#x27;</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;---&quot;</span> + (x+y));
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-title function_">call</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<span class="hljs-comment">//lll---3</span>
</code></pre>
<ul>
<li>应用场景</li>
</ul>
<ul>
<li>实现继承</li>
</ul>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>call</code>可以传递参数,第一个参数为一个对象，从第二个参数往后的所有参数会当成函数的实参传入</p>

        </blockquote>
      <h3 id="apply">apply</h3>
<ul>
<li>应用场景</li>
</ul>
<ul>
<li>经常做一些跟数组有关的操作，比如利用<code class='literal'>Math</code>对象的方法找出数组元素的最大最小值</li>
</ul>
<h3 id="bind">bind</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);
btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>;
    }.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">3000</span>);
}

<span class="hljs-comment">//多个按钮绑定点击事件？？？</span>
</code></pre>
<ul>
<li>应用场景</li>
</ul>
<ul>
<li>只想改变<code class='literal'>this</code>指向，不想调用函数</li>
</ul>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>call</code>、<code class='literal'>apply</code>会改变<code class='literal'>this</code>指向，且调用函数，而<code class='literal'>bind</code>只会改变<code class='literal'>this</code>指向并不会调用函数，但是它会返回一个已经改变了<code class='literal'>this</code>指向的函数拷贝</p>

        </blockquote>
      <h2 id="数组方法">数组方法</h2>
<h3 id="foreach">forEach</h3>
<p>遍历数组，没有返回值</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
    arr[i] = val*<span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> arr[i];
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [2, 4, 6]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// undefined</span>
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>无法使用<code class='literal'>return</code>、<code class='literal'>break</code>命令中途跳出循环</p>

        </blockquote>
      <h3 id="map">map</h3>
<p>遍历数组，有返回值，返回一个新数组</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> val*<span class="hljs-number">2</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [2, 4, 6]</span>
</code></pre>
<h3 id="filter">filter</h3>
<p>遍历数组，有返回值，将满足条件的数组元素放到一个新数组中返回</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> val%<span class="hljs-number">2</span> !== <span class="hljs-number">0</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// [1, 3]</span>
</code></pre>
<h3 id="reduce">reduce</h3>
<p>对数组中的每一个元素执行特定的操作</p>
<pre><code class="language-js"><span class="hljs-comment">//求和数组</span>
<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> c = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">c, v, i</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> c+v;
}, <span class="hljs-number">0</span>)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<span class="hljs-comment">// 9</span>
</code></pre>
<p><code class='literal'>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code></p>
<ul>
<li>callback: 回调函数<ul>
<li>accumulator：它是上一次调用回调时返回的累积值，或initialValue</li>
<li>currentValue：数组中正在处理的元素</li>
<li>index | 可选：数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则从索引1起始</li>
<li>array | 可选：调用reduce()的数组</li>
</ul>
</li>
<li>initialValue | 可选：作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错</li>
</ul>
<ul>
<li>应用场景<ul>
<li>数组求和</li>
<li>对象求和</li>
<li>二维数组转化为一维数组</li>
<li>计算数组中每个元素出现的次数</li>
<li>按属性对<code class='literal'>object</code>分类</li>
<li>数组去重</li>
<li>按顺序运行<code class='literal'>Promise</code></li>
<li>功能性函数管道</li>
<li>使用<code class='literal'>reduce</code>实现<code class='literal'>map</code></li>
</ul>
</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">详细参见MDN吧，还未完全理解</a></p>
<h3 id="some">some</h3>
<p>遍历数组，查找数组中是不是至少有一个符合条件的元素，返回值为<code class='literal'>Boolean</code></p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> flag = arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> val === <span class="hljs-number">2</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flag); <span class="hljs-comment">// true</span>
</code></pre>
<h3 id="every">every</h3>
<p>遍历数组，查找数组中所有元素是否符合条件，返回值为<code class='literal'>Boolean</code></p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> flag = arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">2</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [4, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flag); <span class="hljs-comment">// true</span>
</code></pre>
<blockquote><p><strong>以上为ES5新增的方法↑</strong><br><strong>↓以下为ES6新增的方法</strong></p>
</blockquote><h3 id="from">from</h3>
<p>从一个类数组浅拷贝并返回一个数组</p>
<h3 id="of">of</h3>
<p>创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型</p>
<pre><code class="language-js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">7</span>);       <span class="hljs-comment">// [7] </span>
<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span>

<span class="hljs-title class_">Array</span>(<span class="hljs-number">7</span>);          <span class="hljs-comment">// [ , , , , , , ]</span>
<span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>Array.of()</code>和<code class='literal'>Array</code>构造函数之间的区别在于处理整数参数：<code class='literal'>Array.of(7)</code>创建一个具有单个元素 7 的数组，而<code class='literal'>Array(7)</code>创建一个长度为7的空数组(这是指一个有7个空位(<code class='literal'>empty</code>)的数组，而不是由7个<code class='literal'>undefined</code>组成的数组)</p>

        </blockquote>
      <h3 id="find">find</h3>
<p>遍历数组，返回数组元素中第一个满足条件的元素</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> arr1 = arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">2</span>;
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [4, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1); <span class="hljs-comment">// 4</span>
</code></pre>
<h3 id="includes">includes</h3>
<p>遍历数组，判断数组中是否包含一个指定的值，返回值为<code class='literal'>Boolean</code>，有两个参数，第一个参数为要查找的值，第二个参数为下标，从该下标开始查找</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> f1 = arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [4, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f1); <span class="hljs-comment">// true</span>

<span class="hljs-keyword">var</span> f2 = arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f2); <span class="hljs-comment">//false</span>
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>数组对象中<code class='literal'>from</code>、<code class='literal'>isArray</code>、<code class='literal'>of</code>为静态方法，直接通过构造函数调用<code class='literal'>Array.of</code>，其他方法为原型对象上定义的，使用数组实例对象调用<code class='literal'>[].map</code>、<code class='literal'>new Array().forEach</code></p>

        </blockquote>
      <h3 id="iterator">iterator</h3>
<ul>
<li>yield<br>后面跟一个可遍历的结构，它会调用该结构的遍历器接口</li>
</ul>
<h3 id="forof">for...of</h3>
<ol>
<li><p><code class='literal'>for...of</code>循环会自动遍历<code class='literal'>Generator</code>函数运行时生成的<code class='literal'>Iterator</code>对象，且此时不再需要调用<code class='literal'>next</code>方法</p>
</li>
<li><p>遍历的是数组的元素</p>
</li>
</ol>
<h3 id="forin">for...in</h3>
<ul>
<li>几个缺点：<ol>
<li><code class='literal'>for...in</code>遍历的是数组的下标（字符串数字）或对象的键，且会遍历原型链上所有可枚举的键</li>
<li>某些情况下，<code class='literal'>for...in</code>会以任意顺序遍历键名</li>
<li><code class='literal'>for...in</code>主要用来遍历对象而不是数组</li>
</ol>
</li>
</ul>
<h2 id="对象方法">对象方法</h2>
<h3 id="definepropertyobj-prop-descriptor">defineProperty(obj, prop, descriptor)</h3>
<h3 id="assign">assign</h3>
<p>用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> to = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">var</span> so = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: { <span class="hljs-attr">d</span>: <span class="hljs-number">3</span> } };
<span class="hljs-keyword">var</span> res = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(to, so);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// { a: 1, b: 2, c: { d: 3 } }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(to); <span class="hljs-comment">// { a: 1, b: 2, c: { d: 3 } }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(so); <span class="hljs-comment">// { b: 2, c: { d: 3 } }</span>
to.<span class="hljs-property">c</span>.<span class="hljs-property">d</span> = <span class="hljs-number">4</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(to); <span class="hljs-comment">// { a: 1, b: 2, c: { d: 4 } }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(so); <span class="hljs-comment">// { b: 2, c: { d: 4 } }</span>
</code></pre>
<p><strong>注意：1. 如果源对象和目标对象都有相同的属性，则源对象覆盖目标对象；2. 无法实现深拷贝。</strong></p>
<h3 id="freeze">freeze</h3>
<p>冻结对象，使其属性无法被增删改</p>
<h3 id="is">is</h3>
<p>方法判断两个值是否为同一个值。如果满足以下条件则相等：</p>
<ul>
<li>都是 <code class='literal'>undefined</code></li>
<li>都是 <code class='literal'>null</code></li>
<li>都是 <code class='literal'>true</code> 或 <code class='literal'>false</code></li>
<li>都是相同长度的字符串且相同字符按相同顺序排列</li>
<li>都是相同对象（意味着每个对象有同一个引用）</li>
<li>都是数字且<ul>
<li>都是 <code class='literal'>+0</code></li>
<li>都是 <code class='literal'>-0</code></li>
<li>都是 <code class='literal'>NaN</code></li>
<li>或都是非零而且非 <code class='literal'>NaN</code> 且为同一个值</li>
</ul>
</li>
</ul>
<p>与 <code class='literal'>==</code>、 <code class='literal'>===</code> 的区别：</p>
<ul>
<li><code class='literal'>==</code> 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 <code class='literal'>&quot;&quot; == false</code> 判断为 <code class='literal'>true</code>), 而 <code class='literal'>Object.is</code>不会强制转换两边的值；</li>
<li>与 <code class='literal'>===</code> 运算也不相同。 <code class='literal'>===</code> 运算符 (也包括 <code class='literal'>==</code> 运算符) 将数字 <code class='literal'>-0</code> 和 <code class='literal'>+0</code> 视为相等 ，而将 <code class='literal'>Number.NaN</code> 与 <code class='literal'>NaN</code> 视为不相等。</li>
</ul>
<h2 id="字符串方法">字符串方法</h2>
<p><strong>ES6新增方法</strong></p>
<h3 id="startswith">startsWith</h3>
<h3 id="endswith">endsWith</h3>
<h3 id="repeat">repeat</h3>
<h2 id="strict严格模式">strict严格模式</h2>
<p><code class='literal'>&#39;use strict&#39;</code></p>
<p>严格模式下<code class='literal'>this</code>指向问题：</p>
<ul>
<li>全局作用域中函数中的<code class='literal'>this</code>指向<code class='literal'>undefined</code></li>
<li>构造函数不用<code class='literal'>new</code>实例化直接调用，<code class='literal'>this</code>会报错，因为<code class='literal'>this</code>指向<code class='literal'>undefined</code></li>
<li>使用<code class='literal'>new</code>实例化的<code class='literal'>this</code>还是指向实例对象</li>
<li>定时器<code class='literal'>this</code>还是指向<code class='literal'>window</code></li>
<li>事件、对象中的<code class='literal'>this</code>还是指向调用者</li>
</ul>
<h2 id="promise">Promise</h2>
<h3 id="基本语法">基本语法</h3>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>) {
        <span class="hljs-title function_">resolve</span>(resp);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(error);
    }
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
    <span class="hljs-comment">// 成功回调</span>
}, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-comment">// 失败回调</span>
})
</code></pre>
<p>构建<code class='literal'>Promise</code>实例时传入<code class='literal'>function</code>作为参数，该函数参数包含两个参数：<code class='literal'>resolve</code>和<code class='literal'>reject</code>，当异步操作成功时自动调用<code class='literal'>resolve</code>，失败时调用<code class='literal'>reject</code>，通过<code class='literal'>.then</code>定义成功和失败的回调函数</p>
<p>上例也可如下写：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-comment">//...</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
})
</code></pre>
<ul>
<li><p><code class='literal'>Promise</code>有三种状态：</p>
<ol>
<li><code class='literal'>Pending</code>进行中</li>
<li><code class='literal'>Resolved</code>已完成，又称<code class='literal'>Fulfilled</code></li>
<li><code class='literal'>Rejected</code>已失败</li>
</ol>
</li>
<li><p>举例：封装<code class='literal'>ajax</code></p>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url);
        xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;
        xhr.<span class="hljs-title function_">send</span>();
        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) {
                <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);
            }
        };
        xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
          <span class="hljs-title function_">reject</span>();
        }
    })
}

<span class="hljs-comment">// 调用</span>
<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&quot;./data.json&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">message</span>);
})
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>.then</code>中的返回也是一个<code class='literal'>Promise</code>对象，如果人为返回一个非<code class='literal'>Promise</code>对象的类型，则会被自动转化为<code class='literal'>Promise</code>对象，且状态为<code class='literal'>resolve</code><br>如下所示：</p>

        </blockquote>
      <pre><code class="language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">// 12</span>
})

<span class="hljs-comment">//等价于</span>

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">12</span>);
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">// 12</span>
})
</code></pre>
<h3 id="promiseall">Promise.all</h3>
<p>用于将多个<code class='literal'>Promise</code>实例包装成一个新的<code class='literal'>Promise</code>实例</p>
<ul>
<li>基本用法:</li>
</ul>
<p><code class='literal'>var p = Promise.all([p1, p2, p3]);</code></p>

        <blockquote class='explain'>
          <div style='display:flex'>
            <i></i><span class='tips'>说明：</span>
          </div>
          <p><strong></strong>上面代码中，<code class='literal'>Promise.all</code>方法接受一个数组（或类数组）作为参数，<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>都是<code class='literal'>Promise</code>对象的实例，如果不是，就会先调用<code class='literal'>Promise.resolve</code>方法将其转为<code class='literal'>Promise</code>实例，再进一步处理。</p>

        </blockquote>
      <p><code class='literal'>p</code>的状态由<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>决定，分两种情况：</p>
<ol>
<li>只有<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>的状态都变成<code class='literal'>fulfilled</code>，<code class='literal'>p</code>的状态才会变成<code class='literal'>fulfilled</code>，此时<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>的返回值组成一个数组，传递给<code class='literal'>p</code>的回调函数；</li>
<li>只要<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>之中有一个被<code class='literal'>rejected</code>，<code class='literal'>p</code>的状态就变成<code class='literal'>rejected</code>，此时第一个被<code class='literal'>rejected</code>的实例的返回值，会传递给<code class='literal'>p</code>的回调函数</li>
</ol>
<ul>
<li>应用举例</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> promises = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&quot;./&quot;</span> + id + <span class="hljs-string">&quot;.json&quot;</span>);
});

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">datas</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
})
</code></pre>
<h3 id="promiserace">Promise.race</h3>
<p><code class='literal'>Promise.race</code>方法同样是将多个<code class='literal'>Promise</code>实例包装成一个新的<code class='literal'>Promise</code>实例</p>
<ul>
<li>基本用法</li>
</ul>
<p><code class='literal'>var p = Promise.race([p1, p2, p3]);</code></p>

        <blockquote class='explain'>
          <div style='display:flex'>
            <i></i><span class='tips'>说明：</span>
          </div>
          <p><strong></strong>上面代码中，只要<code class='literal'>p1</code>、<code class='literal'>p2</code>、<code class='literal'>p3</code>之中有一个实例率先改变状态，<code class='literal'>p</code>的状态就跟着改变，且该实例的返回值传递给<code class='literal'>p</code>的回调函数。<code class='literal'>Promise.race</code>的参数如果不是<code class='literal'>Promise</code>实例则会调用<code class='literal'>Promise.resolve</code>将其转为<code class='literal'>Promise</code>实例，再进一步处理。</p>

        </blockquote>
      <ul>
<li>应用举例：请求超时时间</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([
    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&quot;./bigdata.json&quot;</span>),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;请求超时&quot;</span>));
        }, <span class="hljs-number">3000</span>);
    })
]);

p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-comment">//...</span>
})
</code></pre>
<h3 id="promiseresolve">Promise.resolve</h3>
<p><code class='literal'>Promise.resolve</code>方法的参数分成四种情况：</p>
<ul>
<li>参数是一个<code class='literal'>Promise</code>对象</li>
</ul>
<p>如果参数是<code class='literal'>Promise</code>对象，那么<code class='literal'>Promise.resolve</code>不做任何处理，原封不动的返回这个实例</p>
<ul>
<li>参数是一个<code class='literal'>thenable</code>对象</li>
</ul>
<p><code class='literal'>Promise.resolve</code>方法会将这个对象转为<code class='literal'>Promise</code>对象，然后立即执行<code class='literal'>thenable</code>对象的<code class='literal'>then</code>方法</p>
<p><code class='literal'>thenable</code>对象指的是具有<code class='literal'>then</code>方法的对象，如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> thenable = {
    <span class="hljs-attr">then</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) {
        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>);
    }
}

<span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(thenable);
p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<span class="hljs-comment">//42</span>
});
</code></pre>
<ul>
<li>参数是一个非<code class='literal'>thenable</code>对象，或原始值</li>
</ul>
<p><code class='literal'>Promise.resolve</code>方法返回一个<code class='literal'>Promise</code>实例，状态为<code class='literal'>Resolved</code>且返回值为参数值</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello promise&quot;</span>);

p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);<span class="hljs-comment">//hello promise</span>
})
</code></pre>
<ul>
<li>不带任何参数</li>
</ul>
<p><code class='literal'>Promise.resolve</code>方法允许调用时不带参数，直接返回一个<code class='literal'>Resolve</code>状态的<code class='literal'>Promise</code>实例；所以可以使用<code class='literal'>Promise.resolve</code>方法直接创建一个<code class='literal'>Promise</code>实例</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();

<span class="hljs-comment">//等价于</span>

<span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-title function_">resolve</span>();
})
</code></pre>
<h3 id="promisereject">Promise.reject</h3>
<p><code class='literal'>Promise.reject</code>方法也会返回一个新的<code class='literal'>Promise</code>实例，该实例状态为<code class='literal'>rejected</code>。它的参数用法与<code class='literal'>Promise.resolve</code>方法完全一致。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();

<span class="hljs-comment">//等价于</span>

<span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(_, <span class="hljs-function"><span class="hljs-params">reject</span> =&gt;</span> {
    <span class="hljs-title function_">reject</span>();
});
</code></pre>
<h3 id="实现finally">实现finally</h3>
<p><code class='literal'>finally</code>方法用于指定不管<code class='literal'>Promise</code>对象最后状态如何都会执行的操作；它接受一个回调函数作为参数，该函数不管怎样都会执行。</p>
<pre><code class="language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-keyword">let</span> P = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(
        <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> P.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> val),
        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> P.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> { <span class="hljs-keyword">throw</span> err })
    );
}

<span class="hljs-comment">//等价于</span>

<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> P = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(
        <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> {
            <span class="hljs-keyword">let</span> p1 = P.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
                <span class="hljs-keyword">return</span> val;
            })
            <span class="hljs-keyword">return</span> p1;
        },
        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
            <span class="hljs-keyword">let</span> p2 = P.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
                <span class="hljs-keyword">throw</span> err;
            })
            <span class="hljs-keyword">return</span> p2;
        }
    );
}
</code></pre>
<h3 id="应用">应用</h3>
<ul>
<li>异步加载图片<pre><code class="language-js"><span class="hljs-keyword">const</span> loadImage = <span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();
      image.<span class="hljs-property">onload</span> = resolve;
      image.<span class="hljs-property">onerror</span> = reject;
      image.<span class="hljs-property">src</span> = url;
  });
}
</code></pre>
</li>
</ul>
<h2 id="宏任务与微任务">宏任务与微任务</h2>
<p>js任务执行流程<br><img src="img/js%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<ul>
<li>同步任务依次进入主线程执行，异步任务进入<code class='literal'>Event Table</code></li>
<li>当异步任务指定的事情完成时，<code class='literal'>Event Table</code>会将回调函数注册到<code class='literal'>Event Queue</code></li>
<li>主线程内的任务执行完之后，会去<code class='literal'>Event Queue</code>读取对应的函数，进入主线程执行</li>
<li>上述过程会不断重复，也就是常说的<code class='literal'>Event Loop</code>(事件循环)</li>
</ul>
<blockquote><p><strong>js引擎存在<code class='literal'>monitoring process</code>进程，不断的检查主线程执行栈是否为空，一旦为空则去<code class='literal'>Event Queue</code>检查是否有等待被调用的函数</strong></p>
</blockquote><h3 id="宏任务macrotask">宏任务(Macrotask)</h3>
<p>包括：I/O、<code class='literal'>setTimeout</code>、<code class='literal'>setInterval</code>、<code class='literal'>requestAnimationFrame</code></p>
<h3 id="微任务microtask">微任务(Microtask)</h3>
<p>包括：<code class='literal'>MutationObserver</code>、<code class='literal'>Promise.then</code>、<code class='literal'>Promise.catch</code></p>
<blockquote><p><strong>任务执行优先级：同步任务 &gt; 微任务 &gt; 宏任务</strong></p>
</blockquote><ul>
<li>举例说明：</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">//同步任务</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
    <span class="hljs-comment">//宏任务</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);
}, <span class="hljs-number">0</span>)

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> {
    <span class="hljs-comment">//微任务</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);
});

<span class="hljs-comment">//同步任务</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);

<span class="hljs-comment">//控制台输出：</span>
<span class="hljs-comment">//1</span>
<span class="hljs-comment">//4</span>
<span class="hljs-comment">//3</span>
<span class="hljs-comment">//2</span>
</code></pre>
<h2 id="symbol">Symbol</h2>
<h2 id="iterator-1">iterator</h2>
<h2 id="generator函数">Generator函数</h2>
<ul>
<li>基本语法</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">helloGenerator</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;hello&#x27;</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;generator&#x27;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;end&#x27;</span>;
}

<span class="hljs-keyword">var</span> hg = <span class="hljs-title function_">helloGenerator</span>();
</code></pre>
<ul>
<li><p>特性：</p>
<ul>
<li><code class='literal'>Generator</code>函数调用后不会立即执行，而是返回一个遍历器对象(或指针对象)；</li>
<li>只有调用<code class='literal'>Generator</code>函数的<code class='literal'>next</code>方法，才会执行，直到遇到下一个<code class='literal'>yield</code>或<code class='literal'>return</code>；</li>
<li><code class='literal'>yield</code>后面的操作只有在调用的时候才会开始执行</li>
</ul>
</li>
<li><p><code class='literal'>yield</code>与<code class='literal'>return</code>的异同：</p>
<ul>
<li>都能返回跟在语句后的表达式的值；</li>
<li>执行中每遇到<code class='literal'>yield</code>，函数暂停一下，下一个调用<code class='literal'>next</code>再从该位置继续向后执行，而<code class='literal'>return</code>不具备位置记忆功能；</li>
<li>一个函数里面只能执行一次<code class='literal'>return</code>语句，但是可以执行多次<code class='literal'>yield</code>；</li>
<li>普通函数只能返回一次值，因为只能执行一次<code class='literal'>return</code>，<code class='literal'>Generator</code>函数可以返回一系列值，因为可以有任意多个<code class='literal'>yield</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>调用<code class='literal'>next</code>方法的时候可以传入参数，作为上次整个<code class='literal'>yield</code>表达式的返回值；</li>
<li><code class='literal'>yield</code>关键字后跟的语句也会有一个执行结果，该结果会封装成一个对象返回给调用<code class='literal'>next</code>方法的地方：<code class='literal'>{ value: xxx, done: Boolean }</code></li>
</ul>
</li>
</ul>
<p>有点抽象，举例说明：</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;start&quot;</span>);
  <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>+<span class="hljs-number">3</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;p1:&quot;</span>,p1);
  <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">yield</span> <span class="hljs-string">`<span class="hljs-subst">${p1}</span> generator`</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;p2:&quot;</span>,p2);
}

<span class="hljs-keyword">let</span> f = <span class="hljs-title function_">fn</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1:&quot;</span>,f.<span class="hljs-title function_">next</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2:&quot;</span>,f.<span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;world&quot;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3:&quot;</span>,f.<span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;haha&quot;</span>));

<span class="hljs-comment">//f.next()执行</span>
    <span class="hljs-comment">// start</span>
    <span class="hljs-comment">// 1: {value: 4, done: false}</span>
<span class="hljs-comment">//f.next(&quot;world&quot;)执行</span>
    <span class="hljs-comment">// p1: world</span>
    <span class="hljs-comment">// 2: {value: &quot;world generator&quot;, done: false}</span>
<span class="hljs-comment">//f.next(&quot;haha&quot;)执行</span>
    <span class="hljs-comment">// p2: haha</span>
    <span class="hljs-comment">// 3: {value: undefined, done: true}</span>
</code></pre>
<p>通过上例，</p>
<ol>
<li>第一次调用<code class='literal'>next</code>时，从函数开头执行，直到遇到<code class='literal'>yield</code>关键字，此时开始执行<code class='literal'>yield</code>关键字后的表达式<code class='literal'>1+3</code>，得到结果<code class='literal'>4</code>封装进对象<code class='literal'>value</code>属性，并将结果<code class='literal'>{ value: 4, done: false }</code>返回给调用<code class='literal'>next</code>的地方；指针停留在此处，不再继续执行；</li>
<li>第二次调用<code class='literal'>next</code>时，传入参数值<code class='literal'>world</code>，该参数值作为第一次执行结束指针指向的<code class='literal'>yield</code>表达式<code class='literal'>yield 1+3</code>的返回值返回，即上例中的<code class='literal'>p1</code>接收到该值；函数继续从上次停住的地方(即上次执行结果指针指向的地方)执行，直到遇到下一个<code class='literal'>yield</code>关键字，此时执行该<code class='literal'>yield</code>之后的语句<code class='literal'>${p1} generator</code>，同样该语句执行结果封装到返回对象<code class='literal'>value</code>属性：<code class='literal'>{ value: &quot;world generator&quot;, done: false }</code>返回给调用<code class='literal'>next</code>的地方；指针停留在此处，不再继续执行；</li>
<li>同上，直到函数结尾，此时返回对象中<code class='literal'>done</code>为<code class='literal'>true</code>表示函数执行完成。</li>
</ol>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>next</code>方法传入的参数只会作为上次整个<code class='literal'>yield</code>表达式的返回值，看下例</p>

        </blockquote>
      <pre><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span> * (<span class="hljs-keyword">yield</span> (x + <span class="hljs-number">1</span>));
  <span class="hljs-keyword">var</span> z = <span class="hljs-keyword">yield</span> (y / <span class="hljs-number">3</span>);
  <span class="hljs-keyword">return</span> (x + y + z);
}

<span class="hljs-keyword">var</span> a = <span class="hljs-title function_">foo</span>(<span class="hljs-number">5</span>);
a.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// Object{value:6, done:false}</span>
a.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// Object{value:NaN, done:false}</span>
a.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// Object{value:NaN, done:true}</span>

<span class="hljs-keyword">var</span> b = <span class="hljs-title function_">foo</span>(<span class="hljs-number">5</span>);
b.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// { value:6, done:false }</span>
b.<span class="hljs-title function_">next</span>(<span class="hljs-number">12</span>) <span class="hljs-comment">// { value:8, done:false }</span>
b.<span class="hljs-title function_">next</span>(<span class="hljs-number">13</span>) <span class="hljs-comment">// { value:42, done:true }</span>
</code></pre>
<p>上例中，第二次<code class='literal'>next</code>传入的参数<code class='literal'>12</code>只会作为上次<code class='literal'>yield</code>整个表达式<code class='literal'>yield (x + 1)</code>的返回值，因此<code class='literal'>y</code>的值为<code class='literal'>2 * 12</code>等于<code class='literal'>24</code></p>
<h2 id="async与await">async与await</h2>
<h2 id="reflect">Reflect</h2>
<h2 id="proxy">Proxy</h2>
<h1 id="dom">DOM</h1>
<p>DOM结构树示意图</p>
<p><img src="img/DOM%E7%BB%93%E6%9E%84%E6%A0%91.png" alt="DOM结构树示意图"></p>
<h1 id="事件监听方法">事件监听方法</h1>
<h2 id="封装事件">封装事件</h2>
<blockquote><p>addEventListener<br>attachEvent<br>on+事件类型</p>
</blockquote><pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addEvent</span>(<span class="hljs-params">elem, type, handle</span>) {
    <span class="hljs-keyword">if</span> (elem.<span class="hljs-property">addEventListener</span>) {
        elem.<span class="hljs-title function_">addEventListener</span>(type, handle, <span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elem.<span class="hljs-property">attachEvent</span>) {
        elem.<span class="hljs-title function_">attachEvent</span>(type, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            handle.<span class="hljs-title function_">call</span>(elem);
        });
    } <span class="hljs-keyword">else</span> {
        elem[<span class="hljs-string">&#x27;on&#x27;</span> + type] = handle;
    }
}

<span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];
<span class="hljs-title function_">addEvent</span>(div, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerText</span>);
})
</code></pre>
<h2 id="事件冒泡">事件冒泡</h2>
<blockquote><p>结构上(非视觉上)嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。(自底向上)</p>
</blockquote><h2 id="事件捕获">事件捕获</h2>
<blockquote><p>结构上(非视觉上)嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素(事件源元素)。(自顶向下)</p>
</blockquote><blockquote><p>IE没有捕获事件</p>
</blockquote><blockquote><p>addEventListener函数的最后一位形参为false时，事件冒泡；否则事件捕获。</p>
</blockquote><blockquote><p>如果同一元素同一事件既绑定了事件冒泡又绑定了事件捕获，则先捕获后冒泡</p>
</blockquote><pre><code class="language-xml">// html代码
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;con&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// js代码</span>
<span class="hljs-keyword">var</span> wrap = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;wrap&#x27;</span>)[<span class="hljs-number">0</span>];
<span class="hljs-keyword">var</span> con = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;con&#x27;</span>)[<span class="hljs-number">0</span>];
<span class="hljs-keyword">var</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;box&#x27;</span>)[<span class="hljs-number">0</span>];
<span class="hljs-comment">// 冒泡</span>
wrap.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;wrap 冒泡&#x27;</span>)
}, <span class="hljs-literal">false</span>);
con.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;con 冒泡&#x27;</span>)
}, <span class="hljs-literal">false</span>);
box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;box 冒泡&#x27;</span>)
}, <span class="hljs-literal">false</span>);

<span class="hljs-comment">// 捕获</span>
wrap.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;wrap 捕获&#x27;</span>)
}, <span class="hljs-literal">true</span>);
con.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;con 捕获&#x27;</span>)
}, <span class="hljs-literal">true</span>);
box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;box 捕获&#x27;</span>)
}, <span class="hljs-literal">true</span>);
</code></pre>
<p>当点击box区域时，执行结果如下：</p>
<p><img src="img/%E4%BA%8B%E4%BB%B6_%E6%8D%95%E8%8E%B7_%E5%86%92%E6%B3%A1.png" alt="运行结果"></p>
<blockquote><p>focus,blur,change,submit,reset,select等事件不冒泡</p>
</blockquote><h2 id="取消事件冒泡">取消事件冒泡</h2>
<blockquote><p>W3C标准: e.stopPropagation(); 不支持IE9以下版本</p>
</blockquote><blockquote><p>e.cancelBubble = true; 兼容IE, chrome也支持了该方式</p>
</blockquote><h2 id="阻止默认事件">阻止默认事件</h2>
<blockquote><p>W3C标准: e.preventDefault(); 不支持IE9以下版本</p>
</blockquote><blockquote><p>return false; 只支持elem.onclick/... = function() {}方式注册的事件</p>
</blockquote><blockquote><p>e.returnValue = false; 兼容IE,chrome也支持了该方式</p>
</blockquote><h2 id="事件委托">事件委托</h2>
<p>利用事件冒泡和事件源对象进行处理</p>
<blockquote><p><strong>原理：</strong>给父节点添加事件监听器，利用事件冒泡影响到每一个子节点</p>
</blockquote><p>优点：</p>
<ol>
<li>性能--不需要循环所有的元素一个个绑定事件</li>
<li>灵活--当有新的子元素时不需要重新绑定事件</li>
</ol>
<p>需求：ul下有10个li，要求给每个li添加点击事件，点击li时打印li中的文本信息<br>示例：</p>
<pre><code class="language-html">// html代码
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// js代码</span>
<span class="hljs-keyword">var</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)[<span class="hljs-number">0</span>];
ul.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-keyword">var</span> event = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>,
            target = event.<span class="hljs-property">target</span> || event.<span class="hljs-property">srcElement</span>; <span class="hljs-comment">// target兼容火狐, srcElement兼容IE</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">innerText</span>);
}
</code></pre>
<h1 id="键盘事件">键盘事件</h1>
<blockquote><p>keydown可以检测所有按键，但是无法区分字母大小写</p>
</blockquote><blockquote><p>keypress只能检测字符按键，且能根据ASCII值区分字母</p>
</blockquote><h1 id="贪吃蛇">贪吃蛇</h1>
<p><a href="demo/snake.html">贪吃蛇</a></p>
<h1 id="扫雷">扫雷</h1>
<h1 id="js异步加载">js异步加载</h1>
<h2 id="defer">defer</h2>
<p><code class='literal'>&lt;script src=&quot;tools.js&quot; defer=&#39;defer&#39;&gt;&lt;/script&gt;</code></p>
<p>或</p>
<pre><code class="language-js">&lt;script defer=<span class="hljs-string">&#x27;defer&#x27;</span>&gt;
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;kk&#x27;</span>;
    ...	
&lt;/script&gt;
</code></pre>
<p>整个dom文档解析完成之后，才执行；只支持IE</p>
<h2 id="async">async</h2>
<p><code class='literal'>&lt;script src=&#39;tools.js&#39; async=&#39;async&#39;&gt;&lt;/script&gt;</code></p>
<p>加载完成就执行，W3C标准</p>
<h2 id="动态创建script标签，插入到dom中，实现按需加载js">动态创建script标签，插入到DOM中，实现按需加载js</h2>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncLoadScript</span>(<span class="hljs-params">url, callback</span>) {
    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);
    script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;

    <span class="hljs-keyword">if</span> (script.<span class="hljs-property">readyState</span>) { <span class="hljs-comment">// 兼容IE</span>
        script.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">if</span> (script.<span class="hljs-property">readyState</span> == <span class="hljs-string">&#x27;complete&#x27;</span> || script.<span class="hljs-property">readyState</span> == <span class="hljs-string">&#x27;loaded&#x27;</span>) {
                <span class="hljs-title function_">callback</span>();
            }
        }
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 其他浏览器，如：chrome,firefox等</span>
        script.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
            <span class="hljs-title function_">callback</span>();
        }
    }

    script.<span class="hljs-property">src</span> = url; <span class="hljs-comment">// 此时只下载不执行</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script); <span class="hljs-comment">// 此时执行</span>
}
</code></pre>
<h1 id="js时间线">js时间线</h1>
<p><strong>1. 创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = &#39;loading&#39;。</strong></p>
<p><strong>2. 遇到link外部css，创建线程加载，并继续解析文档。</strong></p>
<p><strong>3. 遇到script外部js，并且没有设置async、defer，浏览器加载并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。</strong></p>
<p><strong>4. 遇到script外部js，并且设置有async、defer，浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()）</strong></p>
<p><strong>5. 遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。</strong></p>
<p><strong>6. 当文档解析完成，document.readyState = &#39;interactive&#39;。</strong></p>
<p><strong>7. 文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同，但同样禁止使用document.write()）</strong></p>
<p><strong>8. document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</strong></p>
<p><strong>9. 当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = &#39;complete&#39;，window对象触发load事件。</strong></p>
<p><strong>10. 从此，以异步响应方式处理用户输入、网络事件等。</strong></p>
<h1 id="正则表达式">正则表达式</h1>
<h2 id="正向预查反向预查">正向预查&amp;反向预查</h2>
<h3 id="n">?=n</h3>
<p>匹配字符a并且其后紧跟一个c：<code class='literal'>/a(?=c)/</code></p>
<h3 id="n-1">?!n</h3>
<p>匹配字符a并且其后紧跟的字符不为c：<code class='literal'>/a(?!c)/</code></p>
<h2 id="量词">量词</h2>
<h3 id="n-2">n+</h3>
<p>匹配一个或多个a：<code class='literal'>/a+/</code></p>
<p>匹配一个或多个单词字符：<code class='literal'>/\w+/</code></p>
<h3 id="n-3">n*</h3>
<p>匹配零个或多个a：<code class='literal'>/a*/</code></p>
<p>匹配零个或多个单词字符：<code class='literal'>/\w*/</code></p>
<h3 id="n-4">n?</h3>
<p>匹配零个或一个a：<code class='literal'>/a*/</code></p>
<p>匹配零个或一个单词字符：<code class='literal'>/\w*/</code></p>
<h3 id="nx">n{x}</h3>
<p>匹配3个a：<code class='literal'>/a{3}/</code></p>
<p>匹配3个单词字符：<code class='literal'>/\w{3}/</code></p>
<h3 id="nxy">n{x,y}</h3>
<p>匹配2-3个a：<code class='literal'>/a{2,3}/</code></p>
<p>匹配2-3个单词字符：<code class='literal'>/\w{2,3}/</code></p>
<h3 id="nx-1">n{x,}</h3>
<p>匹配至少2个a：<code class='literal'>/a{2,}/</code></p>
<p>匹配至少2个单词字符：<code class='literal'>/\w{2,}/</code></p>
<h3 id="n-5">n$</h3>
<p>匹配结尾为a的字符：<code class='literal'>/a$/</code></p>
<p>匹配结尾为单词字符的字符：<code class='literal'>/\w$/</code></p>
<h3 id="n-6">^n</h3>
<p>匹配开头为a的字符：<code class='literal'>/^a/</code></p>
<p>匹配开头为单词字符的字符：<code class='literal'>/^\w/</code></p>
<p>匹配以a开头并且以c结尾的字符：<code class='literal'>/^a\w*c$/</code></p>
<h2 id="元字符">元字符</h2>
<h3 id="w">\w</h3>
<p>查找单词字符：[a-zA-Z0-9_]</p>
<h3 id="w-1">\W</h3>
<p>查找非单词字符</p>
<h3 id="d">\d</h3>
<p>查找数字：[0-9]</p>
<h3 id="d-1">\D</h3>
<p>查找非数字字符</p>
<h3 id="s">\s</h3>
<p>查找空白字符(空格、换行等)</p>
<h3 id="s-1">\S</h3>
<p>查找非空白字符</p>
<h3 id="b">\b</h3>
<p>查找单词边界<br>举例：查找a且为单词边界  <code class='literal'>/a\b/</code>, <code class='literal'>&#39;abcda&#39;.match(/a\b/) </code>只会匹配到最后一个字母a</p>
<h3 id="b-1">\B</h3>
<p>查找非单词边界</p>
<h3 id="">.</h3>
<p>查找单个字符，除了换行和行结束符</p>
<h2 id="惰性匹配">惰性匹配</h2>
<blockquote><p>正则表达式遵循<strong>贪婪匹配</strong>原则，即能多匹配就多匹配，如：<code class='literal'>/\d{2,5}/</code>，该表达式能匹配5个就绝对不会匹配2个<br>但是有的时候<strong>贪婪</strong>并不是一件好事，此时就需要<strong>惰性匹配</strong>，如：<code class='literal'>/\d{2,5}?/</code>，该表达式匹配2个之后就不再匹配了</p>
</blockquote><blockquote><p><code class='literal'>&#39;aa111sd&#39;.match(/(\d)+?/g)</code>结果为：<code class='literal'>[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]</code></p>
</blockquote><blockquote><p><code class='literal'>&#39;aa111sd&#39;.match(/(\d)+/g)</code>结果为：<code class='literal'>[&quot;111&quot;]</code></p>
</blockquote><h3 id="惰性匹配情况如下">惰性匹配情况如下</h3>
<p><code class='literal'>{m,n}?</code></p>
<p><code class='literal'>{m,}?</code></p>
<p><code class='literal'>??</code></p>
<p><code class='literal'>*?</code></p>
<p><code class='literal'>+?</code></p>
<h2 id="多选分支">多选分支</h2>
<ol>
<li>匹配&quot;good&quot;和&quot;nice&quot;：<code class='literal'>/good|nice/g</code></li>
<li>需注意：<code class='literal'>&quot;goodbye&quot;.match(/good|goodbye/)</code>结果为：<code class='literal'>[&quot;good&quot;]</code>；若改为<code class='literal'>&quot;goodbye&quot;.match(/goodbye|good/)</code>结果为：<code class='literal'>[&quot;goodbye&quot;]</code></li>
</ol>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>此为惰性匹配,如：<code class='literal'>&quot;#0fbbad&quot;.match(/#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})/)</code>结果为：<code class='literal'>[&quot;#0fb&quot;]</code></p>

        </blockquote>
      <h2 id="非捕获分组：">非捕获分组：<code class='literal'>?:</code></h2>
<p>字符串方法replace中子表达式的运用中介绍到的子表达式可以将当前匹配项捕获到，以便后续引用，因此也称为捕获分组。<br>除了介绍的一些API中使用，还可以用于自身，如下：</p>
<pre><code class="language-js"><span class="hljs-comment">// 匹配日期：yyyy-MM-dd、yyyy/MM/dd、yyyy.MM.dd</span>
<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d{4}(-|\/|\.)\d{2}\1\d{2}/</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2020-01-09&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2020/01/09&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2020.01.09&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2020-01/09&#x27;</span>));
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_%E9%9D%9E%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84_1.png" alt="捕获分组"></p>
<p>如果只想使用括号最原始的功能，后续也不会引用，此时可以使用非捕获分组，如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(ab)+/g</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ababa ab abbaab&#x27;</span>.<span class="hljs-title function_">match</span>(reg));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;捕获分组：$1=&#x27;</span>,<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);

<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(?:ab)+/g</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ababa ab abbaab&#x27;</span>.<span class="hljs-title function_">match</span>(reg));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;非捕获分组：$1=&#x27;</span>,<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_%E9%9D%9E%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84_2.png" alt="非捕获分组"></p>
<h2 id="字符串方法replace中子表达式的运用">字符串方法replace中子表达式的运用</h2>
<blockquote><p>replace的第二个参数可以是字符串，也可以是函数，当是字符串时：<br><code class='literal'>$1,$2...$n</code> 匹配第1-n里捕获的文本<br><code class='literal'>$&amp;</code> 匹配到的字串文本<br>$` 匹配到的字串文本左边的文本<br><code class='literal'>$&#39;</code> 匹配到的字串文本右边的文本<br><code class='literal'>$$</code> 美元符号</p>
</blockquote><pre><code class="language-js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;2,3,4&#x27;</span>;
<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d/g</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27;$&amp;$&amp;$&amp;&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27;$`&#x27;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&quot;$&#x27;&quot;</span>));
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_replace_3.png" alt="replace应用"></p>
<h3 id="正则表达式中用可以构建子表达式，可以有多个子表达式，如果需要重复使用同一个子表达式，可通过12获取，表示第12个子表达式">正则表达式中用()可以构建子表达式，可以有多个子表达式，如果需要重复使用同一个子表达式，可通过$1,$2...获取，表示第1,2...个子表达式</h3>
<ol>
<li>将the_first_name改为小驼峰式: theFirstName<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/_(\w)/g</span>;
<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;the_first_name&#x27;</span>.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span>(<span class="hljs-params">$, $<span class="hljs-number">1</span></span>) {
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($, $<span class="hljs-number">1</span>);
 <span class="hljs-keyword">return</span> $<span class="hljs-number">1.</span><span class="hljs-title function_">toUpperCase</span>();
})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
</code></pre>
<img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_replace_1.png" alt="replace应用"></li>
</ol>
<blockquote><p>如图所示，replace的第二个参数可以是一个回调函数，该函数有多个形参，第一个形参为匹配项，后面的形参为子表达式匹配值；replace会用该函数的返回值作为替换值去替换匹配到的字符</p>
</blockquote><p>上例，若如下写：</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/_(\w)/g</span>;
<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;the_first_name&#x27;</span>.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>.<span class="hljs-title function_">toUpperCase</span>();
})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
</code></pre>
<p>运行会发现结果不尽人意：<code class='literal'>&quot;theNirstName&quot;</code><br>修改上述问题代码，控制台打印时间戳，看是否每匹配到一次就执行一次回调，若如此则不应出现上述错误</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/_(\w)/g</span>;
<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;the_first_name&#x27;</span>.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>());
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>.<span class="hljs-title function_">toUpperCase</span>();
})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
</code></pre>
<p>运行结果如下：</p>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_replace_2.png" alt="replace应用"></p>
<p>由此可见，匹配到几次就会执行几次回调函数，但是执行时间是在所有匹配结束之后统一回调的。</p>
<h2 id="字符串方法split注意项">字符串方法split注意项</h2>
<h3 id="可以有第二个参数，表示结果数组的最大长度">可以有第二个参数，表示结果数组的最大长度</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;html,css,javascript&#x27;</span>;
<span class="hljs-keyword">var</span> arr = str.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/,/</span>, <span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_split_1.png" alt=""></p>
<h3 id="结果数组中可以包含分隔符">结果数组中可以包含分隔符</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;html,css,javascript&#x27;</span>;
<span class="hljs-keyword">var</span> arr = str.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/(,)/</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_split_2.png" alt=""></p>
<h2 id="实战">实战</h2>
<h3 id="1-将100000000000改为100000000000-即从最后一位数字开始-每倒数三位用--分隔">1. 将100000000000改为100.000.000.000, 即从最后一位数字开始, 每倒数三位用 . 分隔</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(\B)(?=((\d){3})+$)/g</span>;

<span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;100000000000&#x27;</span>.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-string">&#x27;.&#x27;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
</code></pre>
<p><img src="img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_1.png" alt="实战1"></p>
<blockquote><p><code class='literal'>/(?!^)(?=((\d){3})+$)/g</code>也可以实现上述功能</p>
</blockquote><h3 id="2-匹配24进制时间：010-920-30-50-9">2. 匹配24进制时间：<code class='literal'>/^([01][0-9]|[2][0-3]):[0-5][0-9]$/</code></h3>
<h3 id="3-同上，区别是0202可以是22：00-910-920-300-91-50-9">3. 同上，区别是02:02可以是2:2：<code class='literal'>^(0?[0-9]|1[0-9]|2[0-3]):(0?[0-9]|[1-5][0-9])$</code></h3>
<h3 id="4-匹配日期：d4-01-910-2-01-9120-9301">4. 匹配日期：<code class='literal'>/^\d{4}-(0?[1-9]|1[0-2])-(0?[1-9]|[12][0-9]|3[01])$/</code></h3>
<h3 id="5-密码校验：16位，2由数字和大小写字母组成，3至少含有数字和小写字母">5. 密码校验：1.6位，2.由数字和大小写字母组成，3.至少含有数字和小写字母</h3>
<pre><code class="language-js"><span class="hljs-comment">// 至少含有数字和小写字母</span>
/((?=.*[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])(?=.*[a-z]))^[<span class="hljs-number">0</span>-9a-zA-Z]{<span class="hljs-number">6</span>}$/g

<span class="hljs-comment">// 至少含有两种字符，方式一</span>
/((?=.*[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])(?=.*[a-z])|(?=.*[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[<span class="hljs-number">0</span>-9A-<span class="hljs-title class_">Za</span>-z]{<span class="hljs-number">6</span>,<span class="hljs-number">12</span>}$/

<span class="hljs-comment">// 至少含有两种字符，方式二</span>
<span class="hljs-regexp">/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/</span>
</code></pre>
<h1 id="css">CSS</h1>
<h2 id="盒子模型">盒子模型</h2>
<ul>
<li>包括：<code class='literal'>content</code>(内容区)、<code class='literal'>padding</code>(内边距)、<code class='literal'>border</code>(边框)、<code class='literal'>margin</code>(外边距)</li>
<li>一般浏览器<code class='literal'>content</code>不包含<code class='literal'>padding</code>和<code class='literal'>border</code>，但<code class='literal'>IE</code>不然</li>
<li>可以使用<code class='literal'>box-sizing: border-box;</code>设置为<code class='literal'>content</code>包含<code class='literal'>padding</code>和<code class='literal'>border</code></li>
</ul>
<h2 id="元素分类">元素分类</h2>
<ul>
<li>块级元素：<code class='literal'>ul</code>、<code class='literal'>ol</code>、<code class='literal'>li</code>、<code class='literal'>dl</code>、<code class='literal'>dd</code>、<code class='literal'>h1-6</code>、<code class='literal'>p</code>、<code class='literal'>section</code>、<code class='literal'>div</code>、<code class='literal'>form</code>、<code class='literal'>address</code>、<code class='literal'>center</code>(居中)、<code class='literal'>hr</code>、<code class='literal'>pre</code>(预格式化)、<code class='literal'>blockquote</code>(文本缩进)、<code class='literal'>marquee</code>(文本滚动)、<code class='literal'>table</code></li>
<li>行内元素：<code class='literal'>a</code>、<code class='literal'>b</code>(加粗)、<code class='literal'>span</code>、<code class='literal'>img</code>、<code class='literal'>input</code>、<code class='literal'>select</code>、<code class='literal'>textarea</code>、<code class='literal'>em</code>(斜体)、<code class='literal'>strong</code>、<code class='literal'>br</code>、<code class='literal'>sup</code>()上标、<code class='literal'>sub</code>(下标)、<code class='literal'>i</code>(斜体)、<code class='literal'>del</code>(删除线)、<code class='literal'>u</code>(下划线)</li>
</ul>
<h2 id="居中">居中</h2>
<pre><code class="language-css"><span class="hljs-comment">/*1.设置父元素弹性布局*/</span>
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">display</span>:flex;
    <span class="hljs-attribute">justify-content</span>: center;
    <span class="hljs-attribute">align-items</span>: center;
}
</code></pre>
<p><a href="./%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E5%B1%85%E4%B8%AD.html">点我看效果</a></p>
<pre><code class="language-css"><span class="hljs-comment">/*2*/</span>
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;
    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>;
}
</code></pre>
<pre><code class="language-css"><span class="hljs-comment">/*3*/</span>
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);
}
</code></pre>
<pre><code class="language-css"><span class="hljs-comment">/*4*/</span>
<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">margin</span>: auto;
}
</code></pre>
<h2 id="css获取容器宽高的方式">css获取容器宽高的方式</h2>
<ol>
<li>el.offsetWidth = width + 左右padding + 左右border</li>
<li>el.clientWidth = width + 左右padding</li>
<li>el.scrollWidth = 实际高度(可视区高度+隐藏区高度)，包括padding但不包含border</li>
</ol>
<h2 id="chrome等浏览器表单提交记住密码后，下次自动填充表单的背景会变成黄色，修改方法">chrome等浏览器表单提交记住密码后，下次自动填充表单的背景会变成黄色，修改方法</h2>
<pre><code><span class="hljs-comment">//方法1</span>
<span class="hljs-attr">input</span>:-webkit-autofill, <span class="hljs-attr">textarea</span>:-webkit-autofill, <span class="hljs-attr">select</span>:-webkit-autofill {
  background-<span class="hljs-attr">color</span>: #fff;<span class="hljs-comment">//设置成元素原本的颜色</span>
  background-<span class="hljs-attr">image</span>: none;
  <span class="hljs-attr">color</span>: <span class="hljs-title function_">rgb</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}
<span class="hljs-comment">//方法2</span>
<span class="hljs-attr">input</span>:-webkit-autofill {
    -webkit-box-<span class="hljs-attr">shadow</span>: 0px <span class="hljs-number">0</span> 3px 100px #ccc inset; <span class="hljs-comment">//背景色</span>
}
</code></pre>
<h2 id="变形动画">变形动画</h2>
<ol>
<li><code class='literal'>transform:translateX(100px) translateY(100px) translateZ(100px) translate(10px, 10px) translate3d(10px, 20px, 20px);</code>平移,Z轴不能使用百分数</li>
<li><code class='literal'>transform:rotateX(45deg) rotate(45deg, 90deg) rotate3d(90deg, 20deg, 30deg);</code>旋转</li>
<li><code class='literal'>transform:scaleX(.5) scale(.5, 2) scale3d(.5, 2, 1.5);</code>缩放</li>
<li><code class='literal'>transform:skewX(45deg) skew(45deg, 60deg);</code>倾斜</li>
<li><code class='literal'>transform-origin:left top 100px;</code>参考点</li>
<li><code class='literal'>backface-visiability:visible/hidden;</code>旋转后背面是否可见,需父级设置<code class='literal'>transform-style: preserve-3d</code></li>
<li><code class='literal'>transform-style:preserve-3d;</code>3d效果</li>
<li><code class='literal'>background:linear-gradient(45deg, red, green 50%, blue 30%);</code>背景颜色线性渐变</li>
<li><code class='literal'>background:radial-gradient(45deg, red, green, blue);</code>径向渐变</li>
</ol>
<h2 id="过渡效果">过渡效果</h2>
<ol>
<li><code class='literal'>transition-property: background,width/all/none;</code>需要过渡的属性</li>
<li><code class='literal'>transition-duration: 2s/1s, 200ms;</code>过渡时间,当设置的过渡属性个数多于过渡时间个数时,第一个属性匹配第一个时间,依次类推;当匹配到最后一个时间时,剩余属性再次从第一个时间开始匹配,依次循环匹配,直至最后属性。</li>
<li><code class='literal'>transition-timing-function: ease/ease-in/ease-out/ease-in-out/linear/cubic-bezier(n,n,n,n);</code>设置过渡效果</li>
<li><code class='literal'>transition-delay: 1s;</code>可设置多值,当设置的过渡属性个数多于该属性个数时,匹配规则同<code class='literal'>transition-duration</code></li>
<li><code class='literal'>transition: all linear 2s 1s;</code>依次为：过渡属性 过渡效果 过渡时间 过渡延时,可设多值：<code class='literal'>width ease 2s 200ms, background linear 1s 1s</code>;</li>
</ol>
<h2 id="动画">动画</h2>
<ol>
<li><code class='literal'>animation-name: xx,yy;</code>动画名称,可设置多个</li>
<li><code class='literal'>animation-duration: 2s,3s;</code>动画时间,当动画设置个数多于动画时间时,匹配规则同<code class='literal'>transition-duration</code></li>
<li><code class='literal'>animation-iteration-count: 1;</code>动画执行次数,可设置动画个数多于该设置时,匹配规则同<code class='literal'>transition-duration</code>;另该值为:<code class='literal'>infinite</code>时动画执行无限次</li>
<li><code class='literal'>animation-direction: normal/reverse/alternate/alternate-reverse;</code>动画方向,始于第一帧(或最后一帧),停止于初始帧,如果执行次数(<code class='literal'>animation-iteration-count</code>)等于1,从第一帧(或最后一帧)平滑过渡到最后一帧(或第一帧),然后跳回初始帧;如果执行次数(<code class='literal'>animation-iteration-count</code>)大于等于2,则有多种情况-&gt;<code class='literal'>normal</code>:从第一帧平滑过渡到最后一帧,然后跳回第一帧再平滑过渡到最后一帧,依此循环执行,直至结束停在初始帧;<code class='literal'>alternate</code>:从第一帧平滑过渡到最后一帧,然后从最后一帧平滑过渡到第一帧,再从第一帧平滑过渡到最后一帧,依此循环执行,直至结束停在初始帧;<code class='literal'>reverse</code>:从最后一帧平滑过渡到第一帧,然后跳回最后一帧再次平滑过渡到第一帧,依此循环执行,直至动画结束停在初始帧;<code class='literal'>alternate-reverse</code>:从最后一帧平滑过渡到第一帧,然后从第一帧平滑过渡到最后一帧,再从最后一帧平滑过渡到第一帧,依此循环执行直至动画结束停在初始帧;具体效果参考:<a href="demo/animation-direction.html">animation-direction案例</a>。</li>
<li><code class='literal'>animation-delay: 2s;</code>动画延时执行</li>
<li><code class='literal'>animation-fill-mode: none/forwards/backwards/both;</code>设置动画执行前后的状态,<code class='literal'>none</code>:始于第一帧,终于初始帧;<code class='literal'>forwards</code>:始于第一帧,终于最后帧;<code class='literal'>backwards</code>:始于第一帧,终于初始帧(不是第一帧);<code class='literal'>both</code>:始于第一帧,终于最后一帧;默认始于初始帧,终于初始帧;具体效果参考:<a href="demo/animation-fill-mode.html">animation-fill-mode案例</a>。</li>
<li><code class='literal'>animation-play-state: running/paused;</code>动画状态运行or暂停</li>
<li><code class='literal'>animation-timing-function:ease/ease-in/ease-out/ease-in-out/linear/steps;</code>动画执行节奏,始于第一帧,停止于初始帧;<code class='literal'>ease</code>(默认):从第一帧开始,逐渐加速然后减速终于最后一帧,停止于初始帧;<code class='literal'>ease-in</code>:从第一帧开始,前一半时间慢速移动,后一半时间快速移动终于最后一帧,停止于初始帧;<code class='literal'>ease-out</code>:从第一帧开始,前一半时间快速移动,后一半时间慢速移动终于最后一帧,停止于初始帧;<code class='literal'>ease-in-out</code>:从第一帧开始,两头慢速移动,中间快速移动终于最后一帧,停止于初始帧;<code class='literal'>linear</code>:从第一帧开始匀速移动终于最后一帧,停止于初始帧;<code class='literal'>step-start</code>:开始时直接从第一帧跳到最后一帧等待动画结束,停止于初始帧,如果动画执行多次,则第一次执行跳到最后一帧后不再动,直至动画执行结束停止于初始帧,等同于<code class='literal'>steps(1,start);step-end</code>:动画执行一次时,动画执行结束的最后一刻直接跳到最后一帧,停止于初始帧,如果动画执行多次,则一直不动,等同于<code class='literal'>steps(1,end);steps(n,start)</code>:n&gt;=2,第一帧和最后一帧之间分n等份执行,停止于初始帧;<code class='literal'>steps(n,end)</code>:第一帧和最后一帧之间分n等份,在第一帧与n-1帧之间执行,开始时等待(执行时间/n)s,然后开始执行,停止于初始帧;也可使用贝塞尔曲线：<code class='literal'>cubic-bezier(n,n,n,n)</code>,自定义<a href="https://cubic-bezier.com">贝塞尔曲线</a>;具体效果参考:<a href="demo/animation-timing-function.html">animation-timing-function案例</a>。</li>
<li><code class='literal'>@keyframes xx { 25% {...} 50% {...} ...}</code>定义动画</li>
</ol>
<h2 id="弹性布局">弹性布局</h2>
<ol>
<li><code class='literal'>display:flex;</code>弹性盒模型</li>
<li><code class='literal'>flex-wrap:nowrap/wrap/wrap-reverse;</code>子元素超出父元素时的显示,<code class='literal'>warp</code>换行或换列显示;<code class='literal'>nowrap</code>不换行/列(默认);<code class='literal'>wrap-reverse</code>反向换行/列</li>
<li><code class='literal'>flex-direction:row/row-reverse/column/column-reverse;</code>布局方向,<code class='literal'>column</code>按列,<code class='literal'>row</code>按行</li>
<li><code class='literal'>flex-flow:column wrap;</code>2,3综合体</li>
<li><code class='literal'>justify-content: flex-start/flex-end/center/space-between/space-around/space-evenly;</code>主轴排列方式</li>
<li><code class='literal'>align-items: stretch(默认)/center/flex-start/flex-end;</code>交叉轴排列方式</li>
<li><code class='literal'>align-content: stretch/flex-start/flex-end/center/space-between/space-around/space-evenly;</code>只适用于多行显示的弹性容器，它的作用是当flex容器在交叉轴上有多余的空间时，对元素的对齐处理</li>
<li><code class='literal'>align-self:stretch/flex-start/flex-end/center;</code>控制单个元素在交叉轴上的排列方式</li>
<li><code class='literal'>flex-grow:1;</code>将弹性盒子的可用空间，分配给弹性元素。可以使用整数或小数声明</li>
<li><code class='literal'>flex-shrink: 2;</code>弹性盒子装不下元素时定义的缩小值</li>
<li><code class='literal'>flex-basis: 100px;</code>分配多余空间之前，项目占据的主轴空间,优先级<code class='literal'>width/height &lt; flex-basis &lt; min/max-width/height</code></li>
<li><code class='literal'>flex:1 0 100px;</code>9、10、11综合体</li>
<li><code class='literal'>order: 1;</code>控制弹性元素的排序,数值越小越在前面，可以负数或整数</li>
</ol>
<h2 id="栅格系统">栅格系统</h2>
<ol>
<li><code class='literal'>display:grid/inline-grid;</code>设置元素为块级/行级栅格容器</li>
<li><code class='literal'>grid-template-rows:100px 100px;</code>划分行,有<code class='literal'>100px 100px、50% 50%、repeat(2, 50%)、repeat(2, 1fr)、repeat(2, 100px)</code>等多种写法</li>
<li><code class='literal'>grid-template-columns:25% 25% 25% 25%;</code>划分列,写法同上</li>
<li><code class='literal'>row-grap: 20px;</code>设置行间距</li>
<li><code class='literal'>column-grap: 30px;</code>设置列间距</li>
<li><code class='literal'>grap: 20px 30px;</code>4,5组合</li>
</ol>
<h2 id="将iconfont图标以unicode的方式引入项目">将iconfont图标以Unicode的方式引入项目</h2>
<ol>
<li>将图标添加到购物车</li>
</ol>
<h1 id="vue">vue</h1>
<h2 id="过滤器filter">过滤器filter</h2>
<h3 id="全局过滤器">全局过滤器</h3>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(filter_name, <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;11&quot;</span>;
});
</code></pre>
<p>调用：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ name | filter_name }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="可传参">可传参</h4>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(filter_name, <span class="hljs-keyword">function</span>(<span class="hljs-params">value, args1, args2</span>) {});
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ name | filter_name(&#x27;args1&#x27;, &#x27;args2&#x27;) }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="可同时使用多个过滤器">可同时使用多个过滤器</h4>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ name | filter_name | filter_name }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>前一个过滤器的返回值会做为后一个过滤器的第一个参数值传入</p>
<p><strong>注意：</strong>过滤器只能用于：双花括号插值和<code class='literal'>v-bind</code>表达式</p>
<h2 id="自定义指令directive">自定义指令directive</h2>
<h3 id="全局指令">全局指令</h3>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(directive_name, {
    <span class="hljs-title function_">bind</span>(<span class="hljs-params"></span>) {},								<span class="hljs-comment">//只调用一次,指令第一次绑定到元素时;一般样式操作写这</span>
    <span class="hljs-title function_">inserted</span>(<span class="hljs-params"></span>) {},						<span class="hljs-comment">//被绑定元素插入父节点时调用;js行为写这</span>
    <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {},              <span class="hljs-comment">//所在组件更新时调用</span>
    <span class="hljs-title function_">componentUpdated</span>(<span class="hljs-params"></span>) {},		<span class="hljs-comment">//所在组件VNode及其子VNodes全部更新时调用</span>
    <span class="hljs-title function_">unbind</span>(<span class="hljs-params"></span>) {}								<span class="hljs-comment">//只调用一次,指令与元素解绑时</span>
})
</code></pre>
<p>第一个参数为指令名称,<strong>注意：</strong>指令在调用时,必须加<code class='literal'>v-</code>前缀<br>第二个参数是一个对象,包含各个阶段的钩子函数<br>钩子函数第一个参数为绑定指令的元素,第二个参数为一个对象,对象有以下属性：</p>
<ol>
<li><code class='literal'>name</code>:指令名</li>
<li><code class='literal'>value</code>:指令的绑定值</li>
<li><code class='literal'>oldValue</code>:旧值</li>
<li><code class='literal'>expression</code>:字符串形式的指令表达式</li>
<li><code class='literal'>arg</code>:传给指令的参数，可选。例如 <code class='literal'>v-my-directive:foo</code> 中，参数为 <code class='literal'>&quot;foo&quot;</code></li>
<li><code class='literal'>modifiers</code>:一个包含修饰符的对象。例如：<code class='literal'>v-my-directive.foo.bar</code> 中，修饰符对象为 <code class='literal'>{ foo: true, bar: true }</code></li>
</ol>
<h3 id="私有指令">私有指令</h3>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
    <span class="hljs-attr">data</span>:...
    <span class="hljs-attr">methods</span>:...
    <span class="hljs-attr">directives</span>: {
        <span class="hljs-attr">directive_name</span>: {
            <span class="hljs-title function_">bind</span>(<span class="hljs-params"></span>) {},
            <span class="hljs-comment">//...</span>
        },
        <span class="hljs-attr">directive_name2</span>:<span class="hljs-comment">//...可以定义多个</span>
    }
});
</code></pre>
<h3 id="简写">简写</h3>
<p>如果指令只用到<code class='literal'>bind</code>和<code class='literal'>update</code>,则可：</p>
<pre><code class="language-js"><span class="hljs-attr">directives</span>: {
    <span class="hljs-attr">directive_name</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">el, binding</span>) {
        <span class="hljs-comment">//...</span>
    }
}
</code></pre>
<p>以上相当于把代码写到<code class='literal'>bind</code>和<code class='literal'>update</code>钩子函数中</p>
<h2 id="定义子组件">定义子组件</h2>
<h3 id="方式一">方式一</h3>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;child-one&#x27;</span>, {			<span class="hljs-comment">// 子组件名称也可为驼峰式:childOne, html代码调用还是&lt;child-one&gt;</span>
    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h1&gt;{{name}}&lt;/h1&gt;&#x27;</span>,
    data () {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;liuh&#x27;</span>
        }
    },
    <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">age</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>
        }
    }
})
</code></pre>
<p>使用</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child-one</span> <span class="hljs-attr">:age</span>=<span class="hljs-string">&#x27;12&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-one</span>&gt;</span>
</code></pre>
<h3 id="方式二">方式二</h3>
<pre><code class="language-js"><span class="hljs-comment">//定义组件模板</span>
&lt;script type=<span class="hljs-string">&quot;text/x-component&quot;</span> id=<span class="hljs-string">&#x27;contentOne&#x27;</span>&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{{name}}-{{age}}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
&lt;/script&gt;
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">//定义组件</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;childOne&#x27;</span>, {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#contentOne&#x27;</span>,
  data () {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;liuh&#x27;</span>
    }
  },
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">age</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>
    }
  }
    
})
</code></pre>
<p>使用</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child-one</span> <span class="hljs-attr">:age</span>=<span class="hljs-string">&#x27;12&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-one</span>&gt;</span>
</code></pre>
<blockquote><p>使用<code class='literal'>Vue.component</code>定义的组件为全局组件</p>
</blockquote><h3 id="方式三私有组件">方式三&lt;私有组件&gt;</h3>
<pre><code class="language-js"><span class="hljs-comment">//组件模板同方式二</span>
<span class="hljs-comment">//定义组件对象</span>
<span class="hljs-keyword">var</span> childOne = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#contentOne&#x27;</span>,
  data () {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;liuh&#x27;</span>
    }
  },
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">age</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>
    }
  }
}

<span class="hljs-comment">//使用此方式定义的组件，需要如下引用</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">components</span>: {childOne}, <span class="hljs-comment">//此处引用子组件</span>
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">m</span>: <span class="hljs-string">&#x27;hello&#x27;</span>
  }
});
</code></pre>
<h3 id="组件模板的定义">组件模板的定义</h3>
<h4 id="使用script标签">使用script标签</h4>
<p>上述例子就是使用<code class='literal'>script</code>标签定义的组件模板，此处不再赘述</p>
<h4 id="使用template标签">使用template标签</h4>
<pre><code>&lt;template id=<span class="hljs-string">&quot;contentOne&quot;</span>&gt;
    <span class="hljs-comment">//模板代码</span>
&lt;/template&gt;
</code></pre>
<h2 id="父子组件通信">父子组件通信</h2>
<h3 id="使用emit">使用$emit</h3>
<pre><code class="language-js"><span class="hljs-comment">// 当子组件发生某些操作时,通过$emit方法,触发监听事件,然后调用父组件的方法对父组件进行操作</span>
<span class="hljs-comment">// 子组件</span>
<span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;calc&#x27;</span>);
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child-one</span> <span class="hljs-attr">:good-list</span>=<span class="hljs-string">&quot;goods&quot;</span> @<span class="hljs-attr">calc</span>=<span class="hljs-string">&#x27;calcPrice()&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-one</span>&gt;</span>
</code></pre>
<p>上述，<code class='literal'>calcPrice</code>为父组件方法</p>
<p>详细见:<a href="demo/vue-$emit.html">父子组件通信之$emit</a></p>
<h3 id="使用sync">使用sync</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child-one</span> <span class="hljs-attr">:good-list.sync</span>=<span class="hljs-string">&quot;goods&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-one</span>&gt;</span>
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>goods</code>为引用变量,sync关键字对普通变量无效</p>

        </blockquote>
      <p>详见:<a href="demo/vue-sync.html">父子组件通信之sync</a></p>
<h2 id="内容分发之slot">内容分发之slot</h2>
<p>俗称：插槽</p>
<h3 id="使用场景">使用场景</h3>
<p>当同一组数据展现的方式不相同时，可以使用插槽</p>
<h3 id="slot使用">slot使用</h3>
<h4 id="260以下版本">2.6.0以下版本</h4>
<pre><code class="language-html">// 子组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span> //具名插槽
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 父组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;parent&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;header&#x27;</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;footer&#x27;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 渲染后
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="260版本">2.6.0版本</h4>
<blockquote><p><code class='literal'>v-slot</code>一般情况下只能添加在<code class='literal'>&lt;template&gt;</code>上</p>
</blockquote><pre><code class="language-html">// 子组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span> //具名插槽
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 父组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;parent&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 渲染后
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h3 id="作用域插槽">作用域插槽</h3>
<p>父组件使用子组件数据</p>
<h4 id="260以下版本-1">2.6.0以下版本</h4>
<pre><code class="language-html">// 子组件,其中list为子组件作用域下定义的变量
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slot1&quot;</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 父组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;parent&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;slot1&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in props.list&quot;</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="260版本-1">2.6.0版本</h4>
<pre><code class="language-html">// 子组件,其中list为子组件作用域下定义的变量
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slot1&quot;</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

// 父组件
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;parent&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-slot:slot1</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in props.list&quot;</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 id="具名插槽缩写">具名插槽缩写</h4>
<p><code class='literal'>v-slot:</code>简写为<code class='literal'>#</code>, 如：<code class='literal'>&lt;template v-slot:slot1=&#39;props&#39;&gt;&lt;/template&gt;</code>可简写为：<code class='literal'>&lt;template #slot1=&#39;props&#39;&gt;&lt;/template&gt;</code></p>
<h2 id="动态组件之is">动态组件之is</h2>
<p><code class='literal'>&lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;</code></p>
<p>当<code class='literal'>type</code>的取值变化时，显示对应的子组件</p>
<blockquote><p>可以不使用<code class='literal'>template</code>标签，使用<code class='literal'>div</code>等标签也可以达到效果</p>
</blockquote><h3 id="keep-alive">keep-alive</h3>
<p>正常情况下，动态组件之间切换时会重新加载组件实例，如果希望组件实例在第一次创建的时候缓存下来，则可以使用<code class='literal'>&lt;keep-alive&gt;</code>标签将动态标签包裹起来</p>
<h3 id="动态组件添加动画效果">动态组件添加动画效果</h3>
<p>动态组件之间切换的时候也可以通过<code class='literal'>&lt;transition&gt;</code>添加过渡动画</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;type=&#x27;login&#x27;&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;type=&#x27;register&#x27;&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;out-in&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;type&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.v-enter</span>, <span class="hljs-selector-class">.v-leave-to</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">150px</span>);
}
<span class="hljs-selector-class">.v-enter-active</span>, <span class="hljs-selector-class">.v-leave-active</span> {
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;
}
</code></pre>
<p>其中，属性<code class='literal'>mode</code>为过渡模式：</p>
<ol>
<li><code class='literal'>out-in</code>:当前元素先过渡离开，完成之后新元素再过渡进入</li>
<li><code class='literal'>in-out</code>:新元素先过渡进入，完成之后当前元素再过渡离开</li>
</ol>
<h2 id="过渡动画">过渡&amp;动画</h2>
<h3 id="transition-group">transition-group</h3>
<p>当需要给<code class='literal'>v-for</code>循环的元素动画时，使用<code class='literal'>transition-group</code></p>
<pre><code>&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;name in person&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>
        {{ name }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
&lt;/div&gt;

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">person</span>: [<span class="hljs-string">&#x27;落樱&#x27;</span>, <span class="hljs-string">&#x27;高山&#x27;</span>, <span class="hljs-string">&#x27;流水&#x27;</span>]
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;小草&#x27;</span>);
    }
  }
});
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.v-enter</span>, <span class="hljs-selector-class">.v-leave-to</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">80px</span>);
}
<span class="hljs-selector-class">.v-enter-active</span>, <span class="hljs-selector-class">.v-leave-active</span> {
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;
}
</code></pre>
<h3 id="appear属性">appear属性</h3>
<p>页面初始化时的入场动画</p>
<h3 id="tag属性">tag属性</h3>
<p>没有该属性时，<code class='literal'>transition-group</code>会被渲染为<code class='literal'>span</code>标签，如果不想被渲染为<code class='literal'>span</code>标签，则使用<code class='literal'>tag</code>属性指定想要被渲染为的标签元素，如：<code class='literal'>&lt;transition-group tag=&quot;ul&quot;&gt;</code></p>
<h3 id="动态组件和路由都可以添加动画">动态组件和路由都可以添加动画</h3>
<pre><code>&lt;transition&gt;
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span>&gt;
&lt;/transition&gt;
</code></pre>
<h2 id="自定义指令">自定义指令</h2>
<h2 id="refs属性">$refs属性</h2>
<p>当需要获取dom元素时，可以使用<code class='literal'>ref</code></p>
<pre><code>&lt;div ref=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;我是一个div&lt;/div&gt;

<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myDiv</span>.<span class="hljs-property">innerText</span>; <span class="hljs-comment">//我是一个div</span>
</code></pre>
<p><code class='literal'>ref</code>属性也可以使用在组件身上</p>
<pre><code>&lt;my-component ref=<span class="hljs-string">&quot;myc&quot;</span>&gt;&lt;/my-component&gt;

<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myc</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">//name是组件my-component的数据(定义在组件data)</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myc</span>.<span class="hljs-title function_">func</span>(); <span class="hljs-comment">//func是组件my-component的方法(定义在组件methods)</span>
</code></pre>
<h2 id="watch侦听器">watch侦听器</h2>
<p><code class='literal'>watch</code>可以监听<code class='literal'>data</code>中定义的变量，如果被监听的变量值发生变化，则会触发相应的方法，该方法有两个参数：第一个参数为新值，第二个参数为旧值</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;&#x27;</span>,
    <span class="hljs-attr">fullName</span>: <span class="hljs-string">&#x27;&#x27;</span>
  },
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-title function_">firstName</span>(<span class="hljs-params">newVal</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = newVal + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;
    },
    <span class="hljs-attr">lastName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + newVal;
    }
  }
});
</code></pre>
<h2 id="computed计算属性">computed计算属性</h2>
<p><code class='literal'>computed</code>计算属性是一个<code class='literal'>function</code>，该<code class='literal'>function</code>内部会用到<code class='literal'>data</code>中的变量，当这些变量值发生变化时，会触发计算属性（即计算属性定义时的<code class='literal'>function</code>执行）重新计算该属性的值</p>
<p><strong>注意：</strong></p>
<ol>
<li>计算属性可以当成一个<code class='literal'>data</code>中的变量调用</li>
<li>计算属性有缓存机制，若其用到的变量的值没有发生变化，则不会再次计算<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">data</span>: {
 <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;&#x27;</span>,
 <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;&#x27;</span>
  },
  <span class="hljs-attr">computed</span>: {
 <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
   <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;
 }
 <span class="hljs-comment">//简写</span>
 <span class="hljs-comment">//fullName() {</span>
 <span class="hljs-comment">//  return this.firstName + &#x27;-&#x27; + this.lastName;</span>
 <span class="hljs-comment">//}</span>
  }
});
</code></pre>
</li>
</ol>
<h2 id="mvvm响应式原理">MVVM响应式原理</h2>
<h3 id="原理图">原理图</h3>
<p><img src="img/MVVM%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt=""></p>
<h3 id="实现">实现</h3>
<h2 id="路由之vue-router">路由之vue-router</h2>
<pre><code class="language-js"><span class="hljs-comment">// 定义两个组件：hello liuh</span>
<span class="hljs-keyword">const</span> hello = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h3&gt;hello&lt;/h3&gt;&#x27;</span>
};
<span class="hljs-keyword">const</span> liuh = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;liuh&lt;/div&gt;&#x27;</span>
};

<span class="hljs-comment">// 定义路由</span>
<span class="hljs-keyword">let</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/hello&#x27;</span>, <span class="hljs-attr">component</span>: hello },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/liuh&#x27;</span>, <span class="hljs-attr">component</span>: liuh }
];
<span class="hljs-keyword">let</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({
  routes
});

<span class="hljs-comment">// 路由引入</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  router
});
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/hello&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/liuh&quot;</span>&gt;</span>liuh<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h3 id="vue-router之参数传递">vue-router之参数传递</h3>
<p><code class='literal'>:id</code></p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/hello/:id&#x27;</span>, <span class="hljs-attr">component</span>: hello },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/liuh&#x27;</span>, <span class="hljs-attr">component</span>: liuh }
];
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> hello = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;&lt;h3&gt;hello{{$route.params.id}}&lt;/h3&gt;&lt;button @click=&quot;show&quot;&gt;参数&lt;/button&gt;&lt;/div&gt;&#x27;</span>,
  <span class="hljs-attr">methods</span>: {
    show () {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>)
    }
  }
};
</code></pre>
<p>在html代码中使用:<code class='literal'>{{$route.params.id}}</code><br>在js代码中使用:<code class='literal'>this.$route.params.id</code></p>
<p>多个参数时<code class='literal'>...path: &#39;/hello/:id/:name&#39;...</code></p>
<h3 id="vue-router之参数类型限制">vue-router之参数类型限制</h3>
<p><code class='literal'>:id(\\d{2})</code></p>
<p>配合正则表达式限制传递参数的类型</p>
<p><code class='literal'>{ path: &#39;/hello/:id(\\d{2})/:name&#39;, component: hello },</code></p>
<h3 id="重定向redirect">重定向redirect</h3>
<pre><code class="language-js">{ <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">redirect</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-attr">params</span>: { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span> } } }
</code></pre>
<p>点击路由:<code class='literal'>about</code>时,会自动重定向到:<code class='literal'>content/3</code></p>
<h3 id="别名alias">别名alias</h3>
<p><code class='literal'>path: &#39;/content/2&#39;, alias: [&#39;/ct2&#39;]</code></p>
<p>路由<code class='literal'>/ct2</code>时,将跳转到<code class='literal'>/content/2</code></p>
<h3 id="命名视图">命名视图</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> header = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h3&gt;header&lt;h3&gt;&#x27;</span>
}

<span class="hljs-keyword">var</span> leftBox = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;left&lt;/div&gt;&#x27;</span>
}

<span class="hljs-keyword">var</span> mainBox = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;main&lt;/div&gt;&#x27;</span>
}

<span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({
  <span class="hljs-attr">routes</span>: [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">components</span>: {
      <span class="hljs-attr">default</span>: header,
      <span class="hljs-attr">left</span>: leftBox,
      <span class="hljs-attr">main</span>: mainBox
    } }
  ]
});

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  router
});
</code></pre>
<h2 id="vue状态管理之vuex">vue状态管理之vuex</h2>
<h3 id="vuex之state">vuex之state</h3>
<pre><code class="language-js"><span class="hljs-keyword">let</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>({
    <span class="hljs-attr">state</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;liuh&#x27;</span>
    }
});

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
    store
});
</code></pre>
<p>引用：<code class='literal'>this.$store.state.name</code></p>
<h3 id="vuex之getters">vuex之getters</h3>
<h3 id="vuex之mutations">vuex之mutations</h3>
<h3 id="vuex之actions">vuex之actions</h3>
<h3 id="vuex之modules">vuex之modules</h3>
<h2 id="nrm">nrm</h2>
<h3 id="安装">安装</h3>
<p><code class='literal'>npm i nrm -g</code></p>
<h3 id="作用">作用</h3>
<p>管理npm镜像，可以自由在各种镜像之间切换</p>
<h3 id="查看当前镜像">查看当前镜像</h3>
<p><code class='literal'>nrm ls</code>列表中前面带 “*” 号为当前使用</p>
<h3 id="切换">切换</h3>
<p><code class='literal'>nrm use taobao</code>切换到淘宝镜像</p>
<h1 id="webpack">webpack</h1>
<h2 id="安装-1">安装</h2>
<p>全局安装</p>
<p><code class='literal'>npm install webpack -g</code></p>
<p><code class='literal'>npm i webpack -g</code>	--简写</p>
<p>局部安装</p>
<p><code class='literal'>npm install webpack --save-dev</code></p>
<p><code class='literal'>npm i webpack -D</code>   --简写</p>
<p><code class='literal'>npm i webpack-cli -D</code></p>
<h2 id="项目初始化">项目初始化</h2>
<p><code class='literal'>npm init -y</code></p>
<h2 id="编译单个文件">编译单个文件</h2>
<p><code class='literal'>npx webpack ./src/main.js -o ./dist/boundle.js</code></p>
<p>文件<code class='literal'>main.js</code>将被编译打包到<code class='literal'>dist/boundle.js</code></p>
<h2 id="webpack-dev-server">webpack-dev-server</h2>
<p>项目自动打包编译工具</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i webpack-dev-server -D</code></p>
<p>由于是局部安装，故无法直接执行相应指令进行打包，需要在<code class='literal'>package.json</code>文件中添加配置项: </p>
<pre><code class="language-json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><p>一些配置  </p>
<ol>
<li><code class='literal'>hot</code>热重载</li>
<li><code class='literal'>port</code>设置端口</li>
<li><code class='literal'>contentBase</code>项目启动后打开页面的根目录，若不设置默认打开项目安装目录下index.html</li>
<li><code class='literal'>open</code>启动后自动打开浏览器</li>
</ol>
<ul>
<li><p>方式一：直接在启动命令添加</p>
<p>  <code class='literal'>webpack-dev-server --open --port 8008 --hot --contentBase ../</code></p>
</li>
<li><p>方式二：在webpack配置文件<code class='literal'>webpack.config.js</code>中添加配置</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-attr">devServer</span>: {
  <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//自动打开浏览器</span>
  <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">//启动端口</span>
  <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;./&#x27;</span>,  <span class="hljs-comment">//启动项目的根目录，启动时默认打开当前目录下的index.html</span>
  <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">//是否开启热重载，当开启时，还需要引入热重载插件</span>
}
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>其中，<code class='literal'>hot: true</code>只开启了热重载开关，若要实现真正的功能还需引入热重载插件，该插件为webpack自带</p>

        </blockquote>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>)

<span class="hljs-attr">plugins</span>: [
  <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>()
]
</code></pre>
<h2 id="html-webpack-plugin">html-webpack-plugin</h2>
<p>根据指定的模板html页面自动生成页面，写入内存；且将编译后的脚本文件使用<code class='literal'>script</code>标签导入该页面。</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i html-webpack-plugin -D</code></p>
<ul>
<li>配置</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)

<span class="hljs-attr">plugins</span>: [
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({
    <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./index.html&#x27;</span>),<span class="hljs-comment">//作为模板的html文件路径</span>
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.html&#x27;</span> <span class="hljs-comment">//生成到内存中的文件名称</span>
  })
]
</code></pre>
<ul>
<li><p>参数</p>
<ul>
<li>template：作为模板的html文件路径</li>
<li>filename：生成到内存中的文件名称</li>
<li>title：生成的html页面title</li>
</ul>
</li>
</ul>
<blockquote><p>详见:<a href="https://github.com/jantimon/html-webpack-plugin#configuration">htmlWebpackPlugin插件参数</a></p>
</blockquote><h2 id="css-loader与style-loader">css-loader与style-loader</h2>
<p>webpack只能编译<code class='literal'>.js</code>文件，如果项目中引入<code class='literal'>.css</code>文件(如：<code class='literal'>import &#39;./css/index.css&#39;</code>)，则需要安装<code class='literal'>style-loader</code>和<code class='literal'>css-loader</code></p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i style-loader css-loader -D</code></p>
<ul>
<li>配置</li>
</ul>
<p>webpack配置文件的<code class='literal'>module</code>&gt;<code class='literal'>rules</code>节点添加一个规则:</p>
<pre><code class="language-js"><span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [
    { <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>] }
  ]
}
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>规则配置的loader从右向左调用</p>

        </blockquote>
      <h2 id="less-loader与sass-loader">less-loader与sass-loader</h2>
<p>处理<code class='literal'>.less</code>类型的样式文件</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i less less-loader -D</code></p>
<ul>
<li>配置</li>
</ul>
<pre><code class="language-js"><span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [
    { <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;less-loader&#x27;</span>] }
  ]
}
</code></pre>
<h2 id="url-loader">url-loader</h2>
<p>项目中引入图片等文件的处理</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i file-loader url-loader -D</code></p>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>其中，<code class='literal'>file-loader</code>为<code class='literal'>url-loader</code>的依赖</p>

        </blockquote>
      <ul>
<li>配置</li>
</ul>
<pre><code class="language-js"><span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [{ 
      	<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpg|png)/</span>, 
      	<span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span> 
      }
  ]
}
</code></pre>
<ul>
<li>参数<ul>
<li>limit：<code class='literal'>file-loader</code>默认会将图片处理为Base64格式的字符串，若不想这么处理，则需该参数；配置该参数后，只会将图片大小（单位：byte）小于参数值的图片进行Base64处理</li>
<li>name：<code class='literal'>file-loader</code>处理后的文件名默认使用32位hash值命名，以防重名文件导致的问题；配置该参数值后，会按照配置规则生成文件名</li>
</ul>
</li>
</ul>
<blockquote><p><code class='literal'>{ test: /\.(jpg|png)/, use: &#39;url-loader?limit=110845&amp;name=[hash:8][name].[ext]&#39; }</code>：其中<code class='literal'>limit=110845</code>表示只会对大小小于110845byte的图片进行Base64加密为字符串；<code class='literal'>[hash:8][name]</code>表示图片名称以8位hash+原图片名拼接，<code class='literal'>[ext]</code>表示使用原图片后缀。<br>上述，等价于：</p>
</blockquote><pre><code class="language-js">{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(jpg|png)$/</span>,
  <span class="hljs-attr">use</span>: [
    {
      <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">limit</span>: <span class="hljs-number">110845</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;[hash:8][name].[ext]&#x27;</span>
      }
    }
  ]
}
</code></pre>
<h2 id="babel-loader">babel-loader</h2>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i babel-loader @babel/core -D</code></p>
<ul>
<li>配置</li>
</ul>
<pre><code class="language-js"><span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [
    {
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
      <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
      <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>
    }
  ]
}
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>其中，<code class='literal'>exclude</code>过滤掉不需要<code class='literal'>babel</code>编译的<code class='literal'>js</code>文件</p>

        </blockquote>
      <h3 id="babel-plugin-transform-runtime">babel-plugin-transform-runtime</h3>
<p><code class='literal'>babel</code>对一些公共方法使用了非常小的辅助代码，比如<code class='literal'>_extend</code>。默认情况下会被添加到每一个需要它的文件中，为了避免重复引入，<code class='literal'>babel</code>引入<code class='literal'>babel-plugin-transform-runtime</code>并且使所有辅助代码从这里引用。</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i @babel/plugin-transform-runtime -D</code></p>
<ul>
<li>配置<ul>
<li><p>方式一：在<code class='literal'>babel</code>配置文件<code class='literal'>.babelrc</code>中添加配置</p>
<pre><code>{
<span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;@babel/transform-runtime&quot;</span>]
}
</code></pre>
</li>
<li><p>方式二：在<code class='literal'>webpack</code>配置文件<code class='literal'>webpack.config.js</code>中添加规则时</p>
<pre><code>{
<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
<span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
<span class="hljs-attr">use</span>: {
    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,
    <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;@babel/transform-runtime&#x27;</span>]
    }
}
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="babel-preset-env">babel-preset-env</h3>
<p>该预设允许你使用最新的<code class='literal'>js</code>，它会将<code class='literal'>es6</code>的语法转换为浏览器识别的语法</p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i @babel/preset-env -D</code></p>
<ul>
<li>配置<ul>
<li><p>方式一：在<code class='literal'>babel</code>配置文件<code class='literal'>.babelrc</code>中添加配置</p>
<pre><code>{
<span class="hljs-string">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>]
}
</code></pre>
</li>
<li><p>方式二：在<code class='literal'>webpack</code>配置文件<code class='literal'>webpack.config.js</code>中添加规则时</p>
<pre><code>{
<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
<span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
<span class="hljs-attr">use</span>: {
    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,
    <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]
    }
}
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="webpack中使用vue">webpack中使用vue</h2>
<h3 id="引入vue">引入vue</h3>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i vue -D</code></p>
<p>安装后就可以使用<code class='literal'>vue</code>语法，首先第一步使用<code class='literal'>import</code>引入<code class='literal'>vue</code>包</p>
<ul>
<li>引入</li>
</ul>
<p><code class='literal'>import Vue from &#39;vue&#39;</code></p>
<ul>
<li>使用</li>
</ul>
<pre><code><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
    <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;111&#x27;</span>
    }
})
</code></pre>
<p>项目启动正常，但发现浏览器控制台报错：</p>
<p><img src="img/webpack%E5%BC%95%E5%85%A5vue%E6%8A%A5%E9%94%99-runtime-only.png" alt="webpack引入vue报错"></p>
<blockquote><p><strong>使用<code class='literal'>import</code>引入模块时的原理：</strong></p>
<ol>
<li>项目根目录下查找<code class='literal'>node_modules</code>目录；</li>
<li><code class='literal'>node_modules</code>目录下查找<code class='literal'>from</code>后以字符串值为名的目录，比如：<code class='literal'>vue</code>；</li>
<li>该目录则为引入模块的根目录，在该目录下查找<code class='literal'>package.json</code>，并查找名为<code class='literal'>main</code>的配置项；</li>
<li><code class='literal'>main</code>配置项的值即导入的依赖包。</li>
</ol>
</blockquote>
        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>以上仅为存在<code class='literal'>node_modules</code>目录的情况。</p>

        </blockquote>
      <p>综上所述，查看<code class='literal'>vue</code>模块根目录下<code class='literal'>package.json</code>中配置项<code class='literal'>main</code>的值：</p>
<p><img src="img/vue-package.josn-main.png" alt=""></p>
<p>对比<code class='literal'>vue.runtime.common.js</code>与<code class='literal'>vue.js</code>文件大小：</p>
<p><img src="img/vue.js%E4%B8%8Evue.runtime.common.js%E5%A4%A7%E5%B0%8F%E5%AF%B9%E6%AF%94.png" alt=""></p>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong>截图所示<code class='literal'>vue.runtime.common.dev.js</code>为开发环境下的<code class='literal'>vue.runtime.common.js</code>依赖包</p>

        </blockquote>
      <p><img src="img/vue.runtime.common.js%E8%AF%A6%E6%83%85.png" alt=""></p>
<p><strong>重点：</strong><code class='literal'>webpack</code>中使用<code class='literal'>import Vue from &#39;vue&#39;</code>引入<code class='literal'>vue</code>依赖包时，引入的<code class='literal'>vue.runtime.common.js</code>并非完整的<code class='literal'>vue</code>，导致了上述的报错。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li>修改配置文件<code class='literal'>package.json</code>：<code class='literal'>&quot;main&quot;: &quot;dist/vue.js&quot;</code>；</li>
<li>引入模块时使用完整路径：<code class='literal'>import Vue from &#39;../node_modules/vue/dist/vue.js&#39;</code>；</li>
<li><code class='literal'>webpack.config.js</code>添加别名配置。<strong>（推荐）</strong></li>
</ol>
<p>上述第三种解决方式的详细配置如下：</p>
<pre><code><span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: {
        <span class="hljs-attr">vue$</span>: <span class="hljs-string">&#x27;vue/dist/vue.js&#x27;</span>
    }
}
</code></pre>
<blockquote><ul>
<li><code class='literal'>resolve</code>与<code class='literal'>entry</code>同级；</li>
<li><code class='literal'>vue$</code>为正则，精确匹配<code class='literal'>import * from &#39;xx&#39;</code>引入时的<code class='literal'>xx</code>值，必须以<code class='literal'>vue</code>结尾才能匹配</li>
</ul>
</blockquote><h3 id="vue-loader">vue-loader</h3>
<p>当使用<code class='literal'>.vue</code>文件进行组件开发时，就需要引入<code class='literal'>vue-loader</code></p>
<ul>
<li>安装</li>
</ul>
<p><code class='literal'>npm i vue-template-compiler vue-loader -D</code></p>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>vue-template-compiler</code>为<code class='literal'>vue-loader</code>的内部依赖</p>

        </blockquote>
      <ul>
<li>配置</li>
</ul>
<p>修改配置文件：<code class='literal'>webpack.config.js</code></p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">VueLoaderPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-loader&#x27;</span>)
<span class="hljs-comment">//或</span>
<span class="hljs-comment">//const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)</span>

<span class="hljs-comment">//......</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    <span class="hljs-comment">//......</span>
    <span class="hljs-attr">module</span>: {
        <span class="hljs-attr">rules</span>: [
            {
                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>,
                <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;vue-loader&#x27;</span>
            }
        ]
    },
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueLoaderPlugin</span>()
    ]
}
</code></pre>

        <blockquote class='notice'>
          <div style='display:flex'>
            <i></i><span class='tips'>注意：</span>
          </div>
          <p><strong></strong><code class='literal'>VueLoaderPlugin</code>这个插件是<em><strong>必须的</strong></em>，它的职责是将你定义过的其它规则复制并应用到<code class='literal'>.vue</code>文件里相应语言的块。例如，如果你有一条匹配<code class='literal'>/\.js$/</code>的规则，那么它会应用到<code class='literal'>.vue</code>文件里的<code class='literal'>&lt;script&gt;</code>块。</p>

        </blockquote>
      <ul>
<li>使用</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./login.vue&#x27;</span>

<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;111&#x27;</span>
  },
  <span class="hljs-comment">// render: function(createElement) {</span>
  <span class="hljs-comment">//   return createElement(login)</span>
  <span class="hljs-comment">// }</span>
  <span class="hljs-attr">components</span>: {
    login
  }
})
</code></pre>
<p>页面如何使用子组件见<code class='literal'>vue</code>部分，此处不再赘述。</p>
<p>详见：<a href="https://vue-loader.vuejs.org/zh/">Vue Loader API</a></p>
<h1 id="es6">ES6</h1>
<h2 id="class-类">class 类</h2>
<ul>
<li><p>class的本质是<code class='literal'>function</code></p>
</li>
<li><p>class可以看做是构造函数的另一种实现</p>
</li>
<li><p>类也具备构造函数的特点：</p>
</li>
</ul>
<ul>
<li>构造函数有原型对象<code class='literal'>prototype</code></li>
<li>构造函数原型对象<code class='literal'>prototype</code>有<code class='literal'>constructor</code>指向构造函数本身</li>
<li>构造函数可以通过原型对象添加方法</li>
<li>构造函数创建的实例对象有<code class='literal'>__proto__</code>指向构造函数的原型对象</li>
</ul>
<h2 id="promise-1">Promise</h2>

2022-04-18 23:33:05 info - node server started at port 1229
2022-04-18 23:33:10 info - node server started at port 1229
2022-04-18 23:36:28 info - node server started at port 1229
